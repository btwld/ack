// GENERATED CODE - DO NOT MODIFY BY HAND

// ignore_for_file: unnecessary_this, unnecessary_new, unnecessary_const, prefer_collection_literals
// ignore_for_file: lines_longer_than_80_chars, unnecessary_null_checks, non_constant_identifier_names

part of 'user_model.dart';

// **************************************************************************
// AckSchemaGenerator
// **************************************************************************

/// Generated schema for User
/// A user model with validation
class UserSchema extends SchemaModel<User> {
  UserSchema([Object? value = null]) : super(value);

  static final ObjectSchema schema = _createSchema();

  static ObjectSchema _createSchema() {
    return Ack.object(
      {
        'email': Ack.string.email(),
        'name': Ack.string.notEmpty(),
        'age': Ack.int.nullable(),
        'password': Ack.string.minLength(8).nullable(),
        'address': AddressSchema.schema,
      },
      required: ['email', 'name', 'password', 'address'],
      additionalProperties: true,
    );
  }

  /// Ensures this schema and its dependencies are registered
  static void ensureInitialize() {
    SchemaRegistry.register<User, UserSchema>(
      (data) => UserSchema(data),
    );
    // Register schema dependencies
    AddressSchema.ensureInitialize();
  }

  @override
  AckSchema getSchema() {
    return schema;
  }

  String get email {
    return getValue<String>('email')!;
  }

  String get name {
    return getValue<String>('name')!;
  }

  int? get age {
    return getValue<int>('age');
  }

  String? get password {
    return getValue<String>('password');
  }

  AddressSchema get address {
    return AddressSchema(getValue<Map<String, dynamic>>('address')!);
  }

  Map<String, Object?> get metadata {
    final map = toMap();
    final knownFields = {'email', 'name', 'age', 'password', 'address'};
    return Map.fromEntries(
        map.entries.where((e) => !knownFields.contains(e.key)));
  }

  @override
  User toModel() {
    if (!isValid) {
      throw AckException(getErrors()!);
    }
    return User(
      email: email,
      name: name,
      age: age,
      password: password,
      address: address.toModel(),
      metadata: metadata,
    );
  }

  /// Convert the schema to a JSON Schema
  static Map<String, Object?> toJsonSchema() {
    final converter = JsonSchemaConverter(schema: schema);
    return converter.toSchema();
  }
}

/// Generated schema for Address
class AddressSchema extends SchemaModel<Address> {
  AddressSchema([Object? value = null]) : super(value);

  static final ObjectSchema schema = _createSchema();

  static ObjectSchema _createSchema() {
    return Ack.object(
      {
        'street': Ack.string.notEmpty(),
        'city': Ack.string.notEmpty(),
        'zip': Ack.string.nullable(),
      },
      required: ['street', 'city'],
      additionalProperties: false,
    );
  }

  /// Ensures this schema and its dependencies are registered
  static void ensureInitialize() {
    SchemaRegistry.register<Address, AddressSchema>(
      (data) => AddressSchema(data),
    );
  }

  @override
  AckSchema getSchema() {
    return schema;
  }

  String get street {
    return getValue<String>('street')!;
  }

  String get city {
    return getValue<String>('city')!;
  }

  String? get zip {
    return getValue<String>('zip');
  }

  @override
  Address toModel() {
    if (!isValid) {
      throw AckException(getErrors()!);
    }
    return Address(
      street: street,
      city: city,
      zip: zip,
    );
  }

  /// Convert the schema to a JSON Schema
  static Map<String, Object?> toJsonSchema() {
    final converter = JsonSchemaConverter(schema: schema);
    return converter.toSchema();
  }
}
