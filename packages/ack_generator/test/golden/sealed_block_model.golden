// GENERATED CODE - DO NOT MODIFY BY HAND

// ignore_for_file: unnecessary_this, unnecessary_new, unnecessary_const, prefer_collection_literals
// ignore_for_file: lines_longer_than_80_chars, unnecessary_null_checks, non_constant_identifier_names

part of 'sealed_block_model.dart';

// **************************************************************************
// AckSchemaGenerator
// **************************************************************************

/// Generated base schema for SealedBlock with inheritance support
/// Base block class with polymorphic subclasses
class SealedBlockSchema<T extends SealedBlock> extends SchemaModel<T> {
  // Constructor that validates input
  SealedBlockSchema([Object? value = null]) : super(value);

  // Main discriminated schema (default entry point for SealedBlock)
  static final DiscriminatedObjectSchema schema = _createDiscriminatedSchema();

  static final ObjectSchema baseSchema = _createBaseSchema();

  static ObjectSchema _createBaseSchema() {
    return Ack.object(
      {
        'type': Ack.string,
        'align': Ack.string.nullable(),
        'flex': Ack.int.nullable(),
        'scrollable': Ack.boolean.nullable(),
      },
      required: ['type'],
      additionalProperties: false,
    );
  }

  static DiscriminatedObjectSchema _createDiscriminatedSchema() {
    return Ack.discriminated(
      discriminatorKey: 'type',
      schemas: {
        'text': TextBlockSchema.schema,
        'image': ImageBlockSchema.schema,
        'widget': WidgetBlockSchema.schema,
      },
    );
  }

  /// Ensures this schema and its dependencies are registered
  static void ensureInitialize() {
    SchemaRegistry.register<SealedBlock, SealedBlockSchema>(
      (data) => SealedBlockSchema(data),
    );
    // Register schema dependencies
    TextBlockSchema.ensureInitialize();
    ImageBlockSchema.ensureInitialize();
    WidgetBlockSchema.ensureInitialize();
  }

  // Override to return the discriminated schema for validation
  @override
  AckSchema getSchema() {
    return schema;
  }

  String get type {
    return getValue<String>('type')!;
  }

  String? get align {
    return getValue<String>('align');
  }

  int? get flex {
    return getValue<int>('flex');
  }

  bool? get scrollable {
    return getValue<bool>('scrollable');
  }

  R when<R>({
    required R Function(TextBlockSchema) text,
    required R Function(ImageBlockSchema) image,
    required R Function(WidgetBlockSchema) widget,
  }) {
    switch (type) {
      case 'text':
        return text(TextBlockSchema(data));
      case 'image':
        return image(ImageBlockSchema(data));
      case 'widget':
        return widget(WidgetBlockSchema(data));
      default:
        throw StateError('Unknown sealedblock type: $type');
    }
  }

  R maybeWhen<R>({
    R Function(TextBlockSchema)? text,
    R Function(ImageBlockSchema)? image,
    R Function(WidgetBlockSchema)? widget,
    required R Function() orElse,
  }) {
    switch (type) {
      case 'text':
        return text?.call(TextBlockSchema(data)) ?? orElse();
      case 'image':
        return image?.call(ImageBlockSchema(data)) ?? orElse();
      case 'widget':
        return widget?.call(WidgetBlockSchema(data)) ?? orElse();
      default:
        return orElse();
    }
  }

  /// Convert the schema to a JSON Schema
  static Map<String, Object?> toJsonSchema() {
    final converter = JsonSchemaConverter(schema: schema);
    return converter.toSchema();
  }
}

/// Generated schema for TextBlock extending SealedBlockSchema
/// A text block with markdown content
class TextBlockSchema extends SealedBlockSchema<TextBlock> {
  // Constructor that validates input
  TextBlockSchema([Object? value = null]) : super(value);

  // Extended schema that inherits from base schema
  static final ObjectSchema schema = _createSchema();

  // Create the validation schema by extending base schema
  static ObjectSchema _createSchema() {
    return SealedBlockSchema.baseSchema.extend(
      {'content': Ack.string},
      required: ['content'],
      additionalProperties: false,
    );
  }

  /// Ensures this schema and its dependencies are registered
  static void ensureInitialize() {
    SchemaRegistry.register<TextBlock, TextBlockSchema>(
      (data) => TextBlockSchema(data),
    );
  }

  // Override to return the extended schema for validation
  @override
  AckSchema getSchema() {
    return schema;
  }

  // Subclass-specific type-safe getters (base getters inherited)
  String get content {
    return getValue<String>('content')!;
  }

  // Model conversion methods
  @override
  TextBlock toModel() {
    if (!isValid) {
      throw AckException(getErrors()!);
    }
    return TextBlock(
        type: type,
        align: align,
        flex: flex,
        scrollable: scrollable,
        content: content);
  }

  /// Convert the schema to a JSON Schema
  static Map<String, Object?> toJsonSchema() {
    final converter = JsonSchemaConverter(schema: schema);
    return converter.toSchema();
  }
}

/// Generated schema for ImageBlock extending SealedBlockSchema
/// An image block with image source and attributes
class ImageBlockSchema extends SealedBlockSchema<ImageBlock> {
  // Constructor that validates input
  ImageBlockSchema([Object? value = null]) : super(value);

  // Extended schema that inherits from base schema
  static final ObjectSchema schema = _createSchema();

  // Create the validation schema by extending base schema
  static ObjectSchema _createSchema() {
    return SealedBlockSchema.baseSchema.extend(
      {
        'src': Ack.string,
        'width': Ack.double.nullable(),
        'height': Ack.double.nullable(),
        'fit': Ack.string.nullable()
      },
      required: ['src'],
      additionalProperties: false,
    );
  }

  /// Ensures this schema and its dependencies are registered
  static void ensureInitialize() {
    SchemaRegistry.register<ImageBlock, ImageBlockSchema>(
      (data) => ImageBlockSchema(data),
    );
  }

  // Override to return the extended schema for validation
  @override
  AckSchema getSchema() {
    return schema;
  }

  // Subclass-specific type-safe getters (base getters inherited)
  String get src {
    return getValue<String>('src')!;
  }

  double? get width {
    return getValue<double>('width');
  }

  double? get height {
    return getValue<double>('height');
  }

  String? get fit {
    return getValue<String>('fit');
  }

  // Model conversion methods
  @override
  ImageBlock toModel() {
    if (!isValid) {
      throw AckException(getErrors()!);
    }
    return ImageBlock(
        type: type,
        align: align,
        flex: flex,
        scrollable: scrollable,
        src: src,
        width: width,
        height: height,
        fit: fit);
  }

  /// Convert the schema to a JSON Schema
  static Map<String, Object?> toJsonSchema() {
    final converter = JsonSchemaConverter(schema: schema);
    return converter.toSchema();
  }
}

/// Generated schema for WidgetBlock extending SealedBlockSchema
/// A widget block with custom properties
class WidgetBlockSchema extends SealedBlockSchema<WidgetBlock> {
  // Constructor that validates input
  WidgetBlockSchema([Object? value = null]) : super(value);

  // Extended schema that inherits from base schema
  static final ObjectSchema schema = _createSchema();

  // Create the validation schema by extending base schema
  static ObjectSchema _createSchema() {
    return SealedBlockSchema.baseSchema.extend(
      {
        'name': Ack.string,
        'properties': Ack.object({}, additionalProperties: true)
      },
      required: ['name'],
      additionalProperties: false,
    );
  }

  /// Ensures this schema and its dependencies are registered
  static void ensureInitialize() {
    SchemaRegistry.register<WidgetBlock, WidgetBlockSchema>(
      (data) => WidgetBlockSchema(data),
    );
  }

  // Override to return the extended schema for validation
  @override
  AckSchema getSchema() {
    return schema;
  }

  // Subclass-specific type-safe getters (base getters inherited)
  String get name {
    return getValue<String>('name')!;
  }

  Map<String, dynamic> get properties {
    return getValue<Map<String, dynamic>>('properties')!;
  }

  // Model conversion methods
  @override
  WidgetBlock toModel() {
    if (!isValid) {
      throw AckException(getErrors()!);
    }
    return WidgetBlock(
        type: type,
        align: align,
        flex: flex,
        scrollable: scrollable,
        name: name,
        properties: properties);
  }

  /// Convert the schema to a JSON Schema
  static Map<String, Object?> toJsonSchema() {
    final converter = JsonSchemaConverter(schema: schema);
    return converter.toSchema();
  }
}
