// GENERATED CODE - DO NOT MODIFY BY HAND

// ignore_for_file: unnecessary_this, unnecessary_new, unnecessary_const, prefer_collection_literals
// ignore_for_file: lines_longer_than_80_chars, unnecessary_null_checks, non_constant_identifier_names

part of 'abstract_shape_model.dart';

// **************************************************************************
// AckSchemaGenerator
// **************************************************************************

/// Generated base schema for Shape with inheritance support
/// A shape that can be a circle, rectangle, or triangle
class ShapeSchema extends BaseSchema<ShapeSchema> {
  /// Default constructor for parser instances
  const ShapeSchema();

  /// Private constructor for validated instances
  const ShapeSchema._valid(Map<String, Object?> data) : super.valid(data);

  static final DiscriminatedObjectSchema schema = Ack.discriminated(
    discriminatorKey: 'type',
    schemas: {
      'circle': CircleSchema.schema,
      'rectangle': RectangleSchema.schema,
      'triangle': TriangleSchema.schema,
    },
  );

  static final ObjectSchema baseSchema = Ack.object(
    {
      'type': Ack.string,
      'color': Ack.string.nullable(),
      'isFilled': Ack.boolean,
    },
    required: ['type'],
    additionalProperties: false,
  );

  /// Parse with validation - core implementation
  @override
  ShapeSchema parse(Object? data) {
    final result = definition.validate(data);
    if (result.isOk) {
      final validatedData = Map<String, Object?>.from(
        result.getOrThrow() as Map<String, Object?>,
      );
      return ShapeSchema._valid(validatedData);
    }
    throw AckException(result.getError());
  }

  /// Ensures this schema and its dependencies are registered
  static void ensureInitialize() {
    SchemaRegistry.register<ShapeSchema>(
      (data) => ShapeSchema(data),
    );
    CircleSchema.ensureInitialize();
    RectangleSchema.ensureInitialize();
    TriangleSchema.ensureInitialize();
  }

  @override
  ObjectSchema get definition => schema;

  String get type => getValue<String>('type')!;

  String? get color => getValue<String>('color');

  bool get isFilled => getValue<bool>('isFilled')!;

  R when<R>({
    required R Function(CircleSchema) circle,
    required R Function(RectangleSchema) rectangle,
    required R Function(TriangleSchema) triangle,
  }) =>
      switch (type) {
        'circle' => circle(CircleSchema(toMap())),
        'rectangle' => rectangle(RectangleSchema(toMap())),
        'triangle' => triangle(TriangleSchema(toMap())),
        _ => throw StateError('Unknown shape type: $type'),
      };

  R maybeWhen<R>({
    R Function(CircleSchema)? circle,
    R Function(RectangleSchema)? rectangle,
    R Function(TriangleSchema)? triangle,
    required R Function() orElse,
  }) =>
      switch (type) {
        'circle' => circle?.call(CircleSchema(toMap())) ?? orElse(),
        'rectangle' => rectangle?.call(RectangleSchema(toMap())) ?? orElse(),
        'triangle' => triangle?.call(TriangleSchema(toMap())) ?? orElse(),
        _ => orElse(),
      };

  /// Convert the schema to a JSON Schema
  static Map<String, Object?> toJsonSchema() =>
      JsonSchemaConverter(schema: schema).toSchema();
}

/// Generated schema for Circle extending ShapeSchema
/// A circular shape with radius
class CircleSchema extends ShapeSchema {
  /// Default constructor for parser instances
  const CircleSchema();

  /// Private constructor for validated instances
  const CircleSchema._valid(Map<String, Object?> data) : super.valid(data);

  static final ObjectSchema schema = ShapeSchema.baseSchema.extend(
    {'radius': Ack.double},
    required: ['radius'],
    additionalProperties: false,
  );

  /// Parse with validation - core implementation
  @override
  CircleSchema parse(Object? data) {
    final result = definition.validate(data);
    if (result.isOk) {
      final validatedData = Map<String, Object?>.from(
        result.getOrThrow() as Map<String, Object?>,
      );
      return CircleSchema._valid(validatedData);
    }
    throw AckException(result.getError());
  }

  /// Ensures this schema and its dependencies are registered
  static void ensureInitialize() {
    SchemaRegistry.register<CircleSchema>(
      (data) => CircleSchema(data),
    );
  }

  @override
  ObjectSchema get definition => schema;

  double get radius => getValue<double>('radius')!;

  /// Convert the schema to a JSON Schema
  static Map<String, Object?> toJsonSchema() =>
      JsonSchemaConverter(schema: schema).toSchema();
}

/// Generated schema for Rectangle extending ShapeSchema
/// A rectangular shape with width and height
class RectangleSchema extends ShapeSchema {
  /// Default constructor for parser instances
  const RectangleSchema();

  /// Private constructor for validated instances
  const RectangleSchema._valid(Map<String, Object?> data) : super.valid(data);

  static final ObjectSchema schema = ShapeSchema.baseSchema.extend(
    {'width': Ack.double, 'height': Ack.double},
    required: ['width', 'height'],
    additionalProperties: false,
  );

  /// Parse with validation - core implementation
  @override
  RectangleSchema parse(Object? data) {
    final result = definition.validate(data);
    if (result.isOk) {
      final validatedData = Map<String, Object?>.from(
        result.getOrThrow() as Map<String, Object?>,
      );
      return RectangleSchema._valid(validatedData);
    }
    throw AckException(result.getError());
  }

  /// Ensures this schema and its dependencies are registered
  static void ensureInitialize() {
    SchemaRegistry.register<RectangleSchema>(
      (data) => RectangleSchema(data),
    );
  }

  @override
  ObjectSchema get definition => schema;

  double get width => getValue<double>('width')!;

  double get height => getValue<double>('height')!;

  /// Convert the schema to a JSON Schema
  static Map<String, Object?> toJsonSchema() =>
      JsonSchemaConverter(schema: schema).toSchema();
}

/// Generated schema for Triangle extending ShapeSchema
/// A triangular shape with three sides
class TriangleSchema extends ShapeSchema {
  /// Default constructor for parser instances
  const TriangleSchema();

  /// Private constructor for validated instances
  const TriangleSchema._valid(Map<String, Object?> data) : super.valid(data);

  static final ObjectSchema schema = ShapeSchema.baseSchema.extend(
    {'sideA': Ack.double, 'sideB': Ack.double, 'sideC': Ack.double},
    required: ['sideA', 'sideB', 'sideC'],
    additionalProperties: false,
  );

  /// Parse with validation - core implementation
  @override
  TriangleSchema parse(Object? data) {
    final result = definition.validate(data);
    if (result.isOk) {
      final validatedData = Map<String, Object?>.from(
        result.getOrThrow() as Map<String, Object?>,
      );
      return TriangleSchema._valid(validatedData);
    }
    throw AckException(result.getError());
  }

  /// Ensures this schema and its dependencies are registered
  static void ensureInitialize() {
    SchemaRegistry.register<TriangleSchema>(
      (data) => TriangleSchema(data),
    );
  }

  @override
  ObjectSchema get definition => schema;

  double get sideA => getValue<double>('sideA')!;

  double get sideB => getValue<double>('sideB')!;

  double get sideC => getValue<double>('sideC')!;

  /// Convert the schema to a JSON Schema
  static Map<String, Object?> toJsonSchema() =>
      JsonSchemaConverter(schema: schema).toSchema();
}
