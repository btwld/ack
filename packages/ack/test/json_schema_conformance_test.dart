import 'dart:convert';
import 'dart:io';
import 'package:ack/ack.dart';
import 'package:test/test.dart';

/// JSON Schema conformance tests comparing Ack's output to Zod v4 reference fixtures.
///
/// These tests ensure that Ack's `.toJsonSchema()` output matches the JSON Schema
/// generated by Zod (which Ack is inspired by) for equivalent schema definitions.
///
/// Reference fixtures are generated using Zod v4's native `z.toJSONSchema()` API
/// and stored in `tools/test-fixtures/reference-schemas/`.
void main() {
  group('JSON Schema Conformance - String Schemas', () {
    test('string-basic', () {
      final ackSchema = Ack.string();
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('string-basic');
      expect(ackOutput, equals(zodReference));
    });

    test('string-nullable', () {
      final ackSchema = Ack.string().nullable();
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('string-nullable');
      expect(ackOutput, equals(zodReference));
    });

    test('string-with-default', () {
      final ackSchema = Ack.string().withDefault('default-value');
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('string-with-default');
      expect(ackOutput, equals(zodReference));
    });

    test('string-with-description', () {
      final ackSchema = Ack.string().describe('A descriptive string field');
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('string-with-description');
      expect(ackOutput, equals(zodReference));
    });

    test('string-minlength', () {
      final ackSchema = Ack.string().minLength(5);
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('string-minlength');
      expect(ackOutput, equals(zodReference));
    });

    test('string-maxlength', () {
      final ackSchema = Ack.string().maxLength(50);
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('string-maxlength');
      expect(ackOutput, equals(zodReference));
    });

    test('string-length-range', () {
      final ackSchema = Ack.string().minLength(3).maxLength(20);
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('string-length-range');
      expect(ackOutput, equals(zodReference));
    });

    test('string-email', () {
      final ackSchema = Ack.string().email();
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('string-email');
      expect(ackOutput, equals(zodReference));
    });

    test('string-url', () {
      final ackSchema = Ack.string().url();
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('string-url');
      expect(ackOutput, equals(zodReference));
    });

    test('string-uuid', () {
      final ackSchema = Ack.string().uuid();
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('string-uuid');
      expect(ackOutput, equals(zodReference));
    });

    test('string-pattern', () {
      final ackSchema = Ack.string().matches(r'^[A-Z][a-z]+');
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('string-pattern');
      expect(ackOutput, equals(zodReference));
    });

    test('string-literal', () {
      final ackSchema = Ack.literal('exact-value');
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('string-literal');
      expect(ackOutput, equals(zodReference));
    });

    test('string-email-required', () {
      final ackSchema = Ack.string().email().minLength(5).maxLength(100);
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('string-email-required');
      expect(ackOutput, equals(zodReference));
    });

    test('string-nullable-with-default', () {
      final ackSchema = Ack.string().nullable().withDefault('fallback');
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('string-nullable-with-default');
      expect(ackOutput, equals(zodReference));
    });
  });

  group('JSON Schema Conformance - Integer Schemas', () {
    test('integer-basic', () {
      final ackSchema = Ack.integer();
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('integer-basic');
      expect(ackOutput, equals(zodReference));
    });

    test('integer-nullable', () {
      final ackSchema = Ack.integer().nullable();
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('integer-nullable');
      expect(ackOutput, equals(zodReference));
    });

    test('integer-with-default', () {
      final ackSchema = Ack.integer().withDefault(42);
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('integer-with-default');
      expect(ackOutput, equals(zodReference));
    });

    test('integer-with-description', () {
      final ackSchema = Ack.integer().describe('A numeric integer field');
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('integer-with-description');
      expect(ackOutput, equals(zodReference));
    });

    test('integer-min', () {
      final ackSchema = Ack.integer().min(0);
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('integer-min');
      expect(ackOutput, equals(zodReference));
    });

    test('integer-max', () {
      final ackSchema = Ack.integer().max(100);
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('integer-max');
      expect(ackOutput, equals(zodReference));
    });

    test('integer-range', () {
      final ackSchema = Ack.integer().min(1).max(10);
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('integer-range');
      expect(ackOutput, equals(zodReference));
    });

    test('integer-positive', () {
      final ackSchema = Ack.integer().positive();
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('integer-positive');
      expect(ackOutput, equals(zodReference));
    });

    test('integer-negative', () {
      final ackSchema = Ack.integer().negative();
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('integer-negative');
      expect(ackOutput, equals(zodReference));
    });

    test('integer-nonnegative', () {
      final ackSchema = Ack.integer().min(0);
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('integer-nonnegative');
      expect(ackOutput, equals(zodReference));
    });

    test('integer-nonpositive', () {
      final ackSchema = Ack.integer().max(0);
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('integer-nonpositive');
      expect(ackOutput, equals(zodReference));
    });

    test('integer-age-example', () {
      final ackSchema = Ack.integer().min(0).max(120).withDefault(0);
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('integer-age-example');
      expect(ackOutput, equals(zodReference));
    });
  });

  group('JSON Schema Conformance - Double Schemas', () {
    test('double-basic', () {
      final ackSchema = Ack.double();
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('double-basic');
      expect(ackOutput, equals(zodReference));
    });

    test('double-nullable', () {
      final ackSchema = Ack.double().nullable();
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('double-nullable');
      expect(ackOutput, equals(zodReference));
    });

    test('double-with-default', () {
      final ackSchema = Ack.double().withDefault(3.14);
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('double-with-default');
      expect(ackOutput, equals(zodReference));
    });

    test('double-with-description', () {
      final ackSchema = Ack.double().describe('A floating point number');
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('double-with-description');
      expect(ackOutput, equals(zodReference));
    });

    test('double-min', () {
      final ackSchema = Ack.double().min(0.0);
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('double-min');
      expect(ackOutput, equals(zodReference));
    });

    test('double-max', () {
      final ackSchema = Ack.double().max(100.0);
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('double-max');
      expect(ackOutput, equals(zodReference));
    });

    test('double-range', () {
      final ackSchema = Ack.double().min(0.0).max(1.0);
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('double-range');
      expect(ackOutput, equals(zodReference));
    });

    test('double-positive', () {
      final ackSchema = Ack.double().positive();
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('double-positive');
      expect(ackOutput, equals(zodReference));
    });

    test('double-finite', () {
      final ackSchema = Ack.double().finite();
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('double-finite');
      expect(ackOutput, equals(zodReference));
    });

    test('double-price-example', () {
      final ackSchema = Ack.double().min(0.01).max(999999.99).withDefault(0.0);
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('double-price-example');
      expect(ackOutput, equals(zodReference));
    });
  });

  group('JSON Schema Conformance - Boolean Schemas', () {
    test('boolean-basic', () {
      final ackSchema = Ack.boolean();
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('boolean-basic');
      expect(ackOutput, equals(zodReference));
    });

    test('boolean-nullable', () {
      final ackSchema = Ack.boolean().nullable();
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('boolean-nullable');
      expect(ackOutput, equals(zodReference));
    });

    test('boolean-with-default-true', () {
      final ackSchema = Ack.boolean().withDefault(true);
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('boolean-with-default-true');
      expect(ackOutput, equals(zodReference));
    });

    test('boolean-with-default-false', () {
      final ackSchema = Ack.boolean().withDefault(false);
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('boolean-with-default-false');
      expect(ackOutput, equals(zodReference));
    });

    test('boolean-with-description', () {
      final ackSchema = Ack.boolean().describe('A flag indicating status');
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('boolean-with-description');
      expect(ackOutput, equals(zodReference));
    });
  });

  group('JSON Schema Conformance - Any Schemas', () {
    test('any-basic', () {
      final ackSchema = Ack.any();
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('any-basic');
      expect(ackOutput, equals(zodReference));
    });

    test('any-nullable', () {
      final ackSchema = Ack.any().nullable();
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('any-nullable');
      expect(ackOutput, equals(zodReference));
    });

    test('any-with-default', () {
      final ackSchema = Ack.any().withDefault('default-any-value');
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('any-with-default');
      expect(ackOutput, equals(zodReference));
    });

    test('any-with-description', () {
      final ackSchema = Ack.any().describe('Accepts any value type');
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('any-with-description');
      expect(ackOutput, equals(zodReference));
    });
  });

  group('JSON Schema Conformance - List Schemas', () {
    test('list-of-strings', () {
      final ackSchema = Ack.list(Ack.string());
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('list-of-strings');
      expect(ackOutput, equals(zodReference));
    });

    test('list-of-integers', () {
      final ackSchema = Ack.list(Ack.integer());
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('list-of-integers');
      expect(ackOutput, equals(zodReference));
    });

    test('list-nullable', () {
      final ackSchema = Ack.list(Ack.string()).nullable();
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('list-nullable');
      expect(ackOutput, equals(zodReference));
    });

    test('list-with-description', () {
      final ackSchema = Ack.list(
        Ack.string(),
      ).describe('A list of string values');
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('list-with-description');
      expect(ackOutput, equals(zodReference));
    });

    test('list-minlength', () {
      final ackSchema = Ack.list(Ack.string()).minItems(1);
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('list-minlength');
      expect(ackOutput, equals(zodReference));
    });

    test('list-maxlength', () {
      final ackSchema = Ack.list(Ack.string()).maxItems(10);
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('list-maxlength');
      expect(ackOutput, equals(zodReference));
    });

    test('list-length-range', () {
      final ackSchema = Ack.list(Ack.integer()).minItems(2).maxItems(5);
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('list-length-range');
      expect(ackOutput, equals(zodReference));
    });

    test('list-of-emails', () {
      final ackSchema = Ack.list(Ack.string().email());
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('list-of-emails');
      expect(ackOutput, equals(zodReference));
    });

    test('list-of-objects', () {
      final ackSchema = Ack.list(
        Ack.object({'id': Ack.integer(), 'name': Ack.string()}),
      );
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('list-of-objects');
      expect(ackOutput, equals(zodReference));
    });
  });

  group('JSON Schema Conformance - Object Schemas', () {
    test('object-basic', () {
      final ackSchema = Ack.object({});
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('object-basic');
      expect(ackOutput, equals(zodReference));
    });

    test('object-nullable', () {
      final ackSchema = Ack.object({}).nullable();
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('object-nullable');
      expect(ackOutput, equals(zodReference));
    });

    test('object-with-description', () {
      final ackSchema = Ack.object({}).describe('An object with properties');
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('object-with-description');
      expect(ackOutput, equals(zodReference));
    });

    test('object-simple-user', () {
      final ackSchema = Ack.object({
        'name': Ack.string(),
        'age': Ack.integer(),
      });
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('object-simple-user');
      expect(ackOutput, equals(zodReference));
    });

    test('object-required-fields', () {
      final ackSchema = Ack.object({
        'id': Ack.integer(),
        'email': Ack.string().email(),
        'isActive': Ack.boolean().withDefault(true),
      });
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('object-required-fields');
      expect(ackOutput, equals(zodReference));
    });

    test('object-optional-fields', () {
      final ackSchema = Ack.object({
        'name': Ack.string(),
        'nickname': Ack.string().optional(),
        'age': Ack.integer().optional(),
      });
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('object-optional-fields');
      expect(ackOutput, equals(zodReference));
    });

    test('object-nested', () {
      final ackSchema = Ack.object({
        'user': Ack.object({
          'name': Ack.string(),
          'email': Ack.string().email(),
        }),
        'settings': Ack.object({
          'theme': Ack.string().withDefault('light'),
          'notifications': Ack.boolean().withDefault(true),
        }),
      });
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('object-nested');
      expect(ackOutput, equals(zodReference));
    });

    test('object-with-array', () {
      final ackSchema = Ack.object({
        'title': Ack.string(),
        'tags': Ack.list(Ack.string()),
        'ratings': Ack.list(Ack.integer().min(1).max(5)),
      });
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('object-with-array');
      expect(ackOutput, equals(zodReference));
    });

    test('object-additional-properties-allowed', () {
      final ackSchema = Ack.object({
        'name': Ack.string(),
      }, additionalProperties: true);
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture(
        'object-additional-properties-allowed',
      );
      expect(ackOutput, equals(zodReference));
    });

    test('object-comprehensive', () {
      final ackSchema = Ack.object({
        'id': Ack.integer().positive(),
        'email': Ack.string().email().minLength(5).maxLength(100),
        'name': Ack.string().minLength(2).maxLength(50),
        'age': Ack.integer().min(0).max(120).nullable(),
        'tags': Ack.list(Ack.string()).nullable(),
        'isActive': Ack.boolean().withDefault(true),
        'metadata': Ack.any().optional(),
      }).describe('A comprehensive user object');
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('object-comprehensive');
      expect(ackOutput, equals(zodReference));
    });
  });

  group('JSON Schema Conformance - AnyOf Schemas', () {
    test('anyof-string-or-integer', () {
      final ackSchema = Ack.anyOf([Ack.string(), Ack.integer()]);
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('anyof-string-or-integer');
      expect(ackOutput, equals(zodReference));
    });

    test('anyof-nullable', () {
      final ackSchema = Ack.anyOf([Ack.string(), Ack.integer()]).nullable();
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('anyof-nullable');
      expect(ackOutput, equals(zodReference));
    });

    test('anyof-with-description', () {
      final ackSchema = Ack.anyOf([
        Ack.string(),
        Ack.boolean(),
      ]).describe('Either a string or boolean value');
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('anyof-with-description');
      expect(ackOutput, equals(zodReference));
    });

    test('anyof-multiple-types', () {
      final ackSchema = Ack.anyOf([
        Ack.string(),
        Ack.integer(),
        Ack.boolean(),
        Ack.list(Ack.string()),
      ]);
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('anyof-multiple-types');
      expect(ackOutput, equals(zodReference));
    });

    test('anyof-objects', () {
      final ackSchema = Ack.anyOf([
        Ack.object({'type': Ack.literal('text'), 'content': Ack.string()}),
        Ack.object({'type': Ack.literal('number'), 'value': Ack.integer()}),
      ]);
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('anyof-objects');
      expect(ackOutput, equals(zodReference));
    });
  });

  group('JSON Schema Conformance - Discriminated Schemas', () {
    test('discriminated-basic', () {
      final ackSchema = Ack.discriminated(
        discriminatorKey: 'type',
        schemas: {
          'user': Ack.object({'name': Ack.string(), 'email': Ack.string()}),
          'admin': Ack.object({'name': Ack.string(), 'role': Ack.string()}),
        },
      );
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('discriminated-basic');
      expect(ackOutput, equals(zodReference));
    });

    test('discriminated-nullable', () {
      final ackSchema = Ack.discriminated(
        discriminatorKey: 'kind',
        schemas: {
          'text': Ack.object({'content': Ack.string()}),
          'image': Ack.object({'url': Ack.string().url()}),
        },
      ).nullable();
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('discriminated-nullable');
      expect(ackOutput, equals(zodReference));
    });

    test('discriminated-with-description', () {
      final ackSchema = Ack.discriminated(
        discriminatorKey: 'eventType',
        schemas: {
          'click': Ack.object({'x': Ack.integer(), 'y': Ack.integer()}),
          'scroll': Ack.object({'delta': Ack.integer()}),
        },
      ).describe('A discriminated event union');
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture(
        'discriminated-with-description',
      );
      expect(ackOutput, equals(zodReference));
    });

    test('discriminated-complex', () {
      final ackSchema = Ack.discriminated(
        discriminatorKey: 'paymentMethod',
        schemas: {
          'card': Ack.object({
            'cardNumber': Ack.string().minLength(16).maxLength(16),
            'cvv': Ack.string().minLength(3).maxLength(4),
            'expiryDate': Ack.string(),
          }),
          'bank': Ack.object({
            'accountNumber': Ack.string(),
            'routingNumber': Ack.string(),
          }),
          'crypto': Ack.object({
            'wallet': Ack.string(),
            'currency': Ack.string(),
          }),
        },
      );
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('discriminated-complex');
      expect(ackOutput, equals(zodReference));
    });
  });

  group('JSON Schema Conformance - Enum Schemas', () {
    test('enum-user-role', () {
      final ackSchema = Ack.enumValues(UserRole.values);
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('enum-user-role');
      expect(ackOutput, equals(zodReference));
    });

    test('enum-status', () {
      final ackSchema = Ack.enumValues(Status.values);
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('enum-status');
      expect(ackOutput, equals(zodReference));
    });

    test('enum-nullable', () {
      final ackSchema = Ack.enumValues(UserRole.values).nullable();
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('enum-nullable');
      expect(ackOutput, equals(zodReference));
    });

    test('enum-with-default', () {
      final ackSchema = Ack.enumValues(
        UserRole.values,
      ).withDefault(UserRole.user);
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('enum-with-default');
      expect(ackOutput, equals(zodReference));
    });

    test('enum-with-description', () {
      final ackSchema = Ack.enumValues(
        Status.values,
      ).describe('Status of the entity');
      final ackOutput = ackSchema.toJsonSchema();
      final zodReference = loadReferenceFixture('enum-with-description');
      expect(ackOutput, equals(zodReference));
    });
  });
}

/// Test enums matching the Zod reference fixtures
enum UserRole { admin, user, guest }

enum Status { active, inactive, pending }

/// Normalizes Zod fixtures by removing JavaScript-specific constraints.
///
/// This function recursively removes JavaScript safe integer bounds
/// (Number.MIN/MAX_SAFE_INTEGER) which don't apply to Dart's arbitrary precision integers.
Map<String, Object?> normalizeZodFixture(Map<String, Object?> zodSchema) {
  final normalized = Map<String, Object?>.from(zodSchema);

  // Remove $schema field if present (not part of core schema structure)
  normalized.remove('\$schema');

  // Helper to remove JS safe bounds from a schema
  void removeSafeBounds(Map<String, Object?> schema) {
    if (schema['type'] == 'integer') {
      if (schema['minimum'] == -9007199254740991) {
        schema.remove('minimum');
      }
      if (schema['maximum'] == 9007199254740991) {
        schema.remove('maximum');
      }
    }
  }

  // Remove bounds from root schema
  removeSafeBounds(normalized);

  // Handle anyOf patterns (e.g., nullable integers, nested anyOf)
  if (normalized['anyOf'] is List) {
    final anyOf = normalized['anyOf'] as List;
    for (var i = 0; i < anyOf.length; i++) {
      final option = anyOf[i];
      if (option is Map<String, Object?>) {
        // Recursively normalize the entire anyOf option
        anyOf[i] = normalizeZodFixture(option);
      }
    }
  }

  // Handle array item schemas
  if (normalized['items'] is Map<String, Object?>) {
    normalized['items'] = normalizeZodFixture(
      normalized['items'] as Map<String, Object?>,
    );
  }

  // Handle object property schemas
  if (normalized['properties'] is Map<String, Object?>) {
    final props = normalized['properties'] as Map<String, Object?>;
    props.forEach((key, value) {
      if (value is Map<String, Object?>) {
        props[key] = normalizeZodFixture(value);
      }
    });
  }

  return normalized;
}

/// Loads a reference JSON Schema fixture generated by Zod.
///
/// Fixtures are located in `tools/test-fixtures/reference-schemas/`.
/// The loaded fixture is automatically normalized to remove JavaScript-specific constraints.
Map<String, Object?> loadReferenceFixture(String name) {
  // Navigate from packages/ack to project root (../../)
  final currentDir = Directory.current.path;
  final projectRoot = currentDir.endsWith('/packages/ack')
      ? currentDir.substring(0, currentDir.length - '/packages/ack'.length)
      : currentDir;
  final fixturePath =
      '$projectRoot/tools/test-fixtures/reference-schemas/$name.json';
  final file = File(fixturePath);

  if (!file.existsSync()) {
    throw Exception(
      'Reference fixture not found: $fixturePath\n'
      'Make sure to run: npm run fixtures (from tools/ directory)',
    );
  }

  final content = file.readAsStringSync();
  final zodSchema = jsonDecode(content) as Map<String, Object?>;

  // Normalize Zod fixtures to remove JS-specific constraints
  return normalizeZodFixture(zodSchema);
}
