import 'dart:convert';
import 'dart:io';

import 'package:ack/ack.dart';
import 'package:test/test.dart';

/// Zod conformance tests for JsonSchema parsing.
///
/// These tests verify that JsonSchema can correctly parse JSON Schema documents
/// generated by Zod v4, ensuring compatibility with the industry-standard
/// reference implementation.
///
/// Reference fixtures are generated using Zod's native `z.toJSONSchema()` API
/// and stored in `tools/test-fixtures/reference-schemas/`.
void main() {
  group('JsonSchema Zod Conformance - String Schemas', () {
    test('parses Zod string-basic fixture', () {
      final zodJson = loadReferenceFixture('string-basic');
      final schema = JsonSchema.fromJson(zodJson);

      expect(schema.singleType, JsonSchemaType.string);
    });

    test('parses Zod string-nullable fixture', () {
      final zodJson = loadReferenceFixture('string-nullable');
      final schema = JsonSchema.fromJson(zodJson);

      expect(schema.anyOf, isNotNull);
      expect(schema.anyOf, hasLength(2));
    });

    test('parses Zod string-email fixture', () {
      final zodJson = loadReferenceFixture('string-email');
      final schema = JsonSchema.fromJson(zodJson);

      expect(schema.singleType, JsonSchemaType.string);
      expect(schema.wellKnownFormat, WellKnownFormat.email);
    });

    test('parses Zod string-url fixture', () {
      final zodJson = loadReferenceFixture('string-url');
      final schema = JsonSchema.fromJson(zodJson);

      expect(schema.singleType, JsonSchemaType.string);
      expect(schema.wellKnownFormat, WellKnownFormat.uri);
    });

    test('parses Zod string-uuid fixture', () {
      final zodJson = loadReferenceFixture('string-uuid');
      final schema = JsonSchema.fromJson(zodJson);

      expect(schema.singleType, JsonSchemaType.string);
      expect(schema.wellKnownFormat, WellKnownFormat.uuid);
    });

    test('parses Zod string-pattern fixture', () {
      final zodJson = loadReferenceFixture('string-pattern');
      final schema = JsonSchema.fromJson(zodJson);

      expect(schema.singleType, JsonSchemaType.string);
      expect(schema.pattern, isNotNull);
    });

    test('parses Zod string-minlength fixture', () {
      final zodJson = loadReferenceFixture('string-minlength');
      final schema = JsonSchema.fromJson(zodJson);

      expect(schema.singleType, JsonSchemaType.string);
      expect(schema.minLength, 5);
    });

    test('parses Zod string-maxlength fixture', () {
      final zodJson = loadReferenceFixture('string-maxlength');
      final schema = JsonSchema.fromJson(zodJson);

      expect(schema.singleType, JsonSchemaType.string);
      expect(schema.maxLength, 50);
    });
  });

  group('JsonSchema Zod Conformance - Integer Schemas', () {
    test('parses Zod integer-basic fixture', () {
      final zodJson = loadReferenceFixture('integer-basic');
      final schema = JsonSchema.fromJson(zodJson);

      expect(schema.singleType, JsonSchemaType.integer);
    });

    test('parses Zod integer-nullable fixture', () {
      final zodJson = loadReferenceFixture('integer-nullable');
      final schema = JsonSchema.fromJson(zodJson);

      expect(schema.anyOf, isNotNull);
      expect(schema.anyOf, hasLength(2));
    });

    test('parses Zod integer-min fixture', () {
      final zodJson = loadReferenceFixture('integer-min');
      final schema = JsonSchema.fromJson(zodJson);

      expect(schema.singleType, JsonSchemaType.integer);
      expect(schema.minimum, 0);
    });

    test('parses Zod integer-max fixture', () {
      final zodJson = loadReferenceFixture('integer-max');
      final schema = JsonSchema.fromJson(zodJson);

      expect(schema.singleType, JsonSchemaType.integer);
      expect(schema.maximum, 100);
    });

    test('parses Zod integer-positive fixture', () {
      final zodJson = loadReferenceFixture('integer-positive');
      final schema = JsonSchema.fromJson(zodJson);

      expect(schema.singleType, JsonSchemaType.integer);
      expect(schema.exclusiveMinimum, 0);
    });

    test('parses Zod integer-negative fixture', () {
      final zodJson = loadReferenceFixture('integer-negative');
      final schema = JsonSchema.fromJson(zodJson);

      expect(schema.singleType, JsonSchemaType.integer);
      expect(schema.exclusiveMaximum, 0);
    });
  });

  group('JsonSchema Zod Conformance - Double Schemas', () {
    test('parses Zod double-basic fixture', () {
      final zodJson = loadReferenceFixture('double-basic');
      final schema = JsonSchema.fromJson(zodJson);

      expect(schema.singleType, JsonSchemaType.number);
    });

    test('parses Zod double-nullable fixture', () {
      final zodJson = loadReferenceFixture('double-nullable');
      final schema = JsonSchema.fromJson(zodJson);

      expect(schema.anyOf, isNotNull);
      expect(schema.anyOf, hasLength(2));
    });

    test('parses Zod double-min fixture', () {
      final zodJson = loadReferenceFixture('double-min');
      final schema = JsonSchema.fromJson(zodJson);

      expect(schema.singleType, JsonSchemaType.number);
      expect(schema.minimum, 0.0);
    });

    test('parses Zod double-positive fixture', () {
      final zodJson = loadReferenceFixture('double-positive');
      final schema = JsonSchema.fromJson(zodJson);

      expect(schema.singleType, JsonSchemaType.number);
      expect(schema.exclusiveMinimum, 0);
    });
  });

  group('JsonSchema Zod Conformance - Boolean Schemas', () {
    test('parses Zod boolean-basic fixture', () {
      final zodJson = loadReferenceFixture('boolean-basic');
      final schema = JsonSchema.fromJson(zodJson);

      expect(schema.singleType, JsonSchemaType.boolean);
    });

    test('parses Zod boolean-nullable fixture', () {
      final zodJson = loadReferenceFixture('boolean-nullable');
      final schema = JsonSchema.fromJson(zodJson);

      expect(schema.anyOf, isNotNull);
      expect(schema.anyOf, hasLength(2));
    });
  });

  group('JsonSchema Zod Conformance - Any Schemas', () {
    test('parses Zod any-basic fixture', () {
      final zodJson = loadReferenceFixture('any-basic');
      final schema = JsonSchema.fromJson(zodJson);

      // Empty schema or anyOf - just verify it parses
      expect(schema, isNotNull);
    });

    test('parses Zod any-nullable fixture', () {
      final zodJson = loadReferenceFixture('any-nullable');
      final schema = JsonSchema.fromJson(zodJson);

      // Should accept as valid schema
      expect(schema, isNotNull);
    });
  });

  group('JsonSchema Zod Conformance - List Schemas', () {
    test('parses Zod list-of-strings fixture', () {
      final zodJson = loadReferenceFixture('list-of-strings');
      final schema = JsonSchema.fromJson(zodJson);

      expect(schema.singleType, JsonSchemaType.array);
      expect(schema.items, isNotNull);
      expect(schema.items!.singleType, JsonSchemaType.string);
    });

    test('parses Zod list-of-integers fixture', () {
      final zodJson = loadReferenceFixture('list-of-integers');
      final schema = JsonSchema.fromJson(zodJson);

      expect(schema.singleType, JsonSchemaType.array);
      expect(schema.items, isNotNull);
      expect(schema.items!.singleType, JsonSchemaType.integer);
    });

    test('parses Zod list-nullable fixture', () {
      final zodJson = loadReferenceFixture('list-nullable');
      final schema = JsonSchema.fromJson(zodJson);

      expect(schema.anyOf, isNotNull);
      expect(schema.anyOf, hasLength(2));
    });

    test('parses Zod list-minlength fixture', () {
      final zodJson = loadReferenceFixture('list-minlength');
      final schema = JsonSchema.fromJson(zodJson);

      expect(schema.singleType, JsonSchemaType.array);
      expect(schema.minItems, 1);
    });

    test('parses Zod list-maxlength fixture', () {
      final zodJson = loadReferenceFixture('list-maxlength');
      final schema = JsonSchema.fromJson(zodJson);

      expect(schema.singleType, JsonSchemaType.array);
      expect(schema.maxItems, 10);
    });
  });

  group('JsonSchema Zod Conformance - Object Schemas', () {
    test('parses Zod object-basic fixture', () {
      final zodJson = loadReferenceFixture('object-basic');
      final schema = JsonSchema.fromJson(zodJson);

      expect(schema.singleType, JsonSchemaType.object);
    });

    test('parses Zod object-nullable fixture', () {
      final zodJson = loadReferenceFixture('object-nullable');
      final schema = JsonSchema.fromJson(zodJson);

      expect(schema.anyOf, isNotNull);
      expect(schema.anyOf, hasLength(2));
    });

    test('parses Zod object-simple-user fixture', () {
      final zodJson = loadReferenceFixture('object-simple-user');
      final schema = JsonSchema.fromJson(zodJson);

      expect(schema.singleType, JsonSchemaType.object);
      expect(schema.properties, isNotNull);
      expect(schema.properties!['name'], isNotNull);
      expect(schema.properties!['age'], isNotNull);
    });

    test('parses Zod object-nested fixture', () {
      final zodJson = loadReferenceFixture('object-nested');
      final schema = JsonSchema.fromJson(zodJson);

      expect(schema.singleType, JsonSchemaType.object);
      expect(schema.properties, isNotNull);
      // Should have nested object properties
      expect(schema.properties!.values.any((s) => s.singleType == JsonSchemaType.object), isTrue);
    });
  });

  group('JsonSchema Zod Conformance - AnyOf Schemas', () {
    test('parses Zod anyof-string-or-integer fixture', () {
      final zodJson = loadReferenceFixture('anyof-string-or-integer');
      final schema = JsonSchema.fromJson(zodJson);

      expect(schema.anyOf, isNotNull);
      expect(schema.anyOf!.length, greaterThanOrEqualTo(2));
    });

    test('parses Zod anyof-nullable fixture', () {
      final zodJson = loadReferenceFixture('anyof-nullable');
      final schema = JsonSchema.fromJson(zodJson);

      expect(schema.anyOf, isNotNull);
      // Should have null option
      expect(schema.anyOf!.any((s) => s.singleType == JsonSchemaType.null_), isTrue);
    });

    test('parses Zod anyof-multiple-types fixture', () {
      final zodJson = loadReferenceFixture('anyof-multiple-types');
      final schema = JsonSchema.fromJson(zodJson);

      expect(schema.anyOf, isNotNull);
      expect(schema.anyOf!.length, greaterThanOrEqualTo(3));
    });
  });

  group('JsonSchema Zod Conformance - Discriminated Schemas', () {
    test('parses Zod discriminated-basic fixture', () {
      final zodJson = loadReferenceFixture('discriminated-basic');
      final schema = JsonSchema.fromJson(zodJson);

      // Discriminated unions use anyOf
      expect(schema.anyOf, isNotNull);
      expect(schema.anyOf!.length, greaterThanOrEqualTo(2));
      // All options should be objects
      expect(
        schema.anyOf!.every((s) => s.singleType == JsonSchemaType.object),
        isTrue,
      );
    });

    test('parses Zod discriminated-nullable fixture', () {
      final zodJson = loadReferenceFixture('discriminated-nullable');
      final schema = JsonSchema.fromJson(zodJson);

      expect(schema.anyOf, isNotNull);
      // Should have null option
      expect(schema.anyOf!.any((s) => s.singleType == JsonSchemaType.null_), isTrue);
    });
  });

  group('JsonSchema Zod Conformance - Round-Trip', () {
    test('round-trips all Zod string fixtures', () {
      final fixtures = [
        'string-basic',
        'string-nullable',
        'string-email',
        'string-url',
        'string-uuid',
        'string-pattern',
        'string-minlength',
        'string-maxlength',
      ];

      for (final fixtureName in fixtures) {
        final input = loadReferenceFixture(fixtureName);
        final schema = JsonSchema.fromJson(input);
        final output = schema.toJson();

        // The output should be a valid JSON Schema that can be re-parsed
        expect(
          () => JsonSchema.fromJson(output),
          returnsNormally,
          reason: 'Failed to round-trip $fixtureName',
        );
      }
    });

    test('round-trips all Zod object fixtures', () {
      final fixtures = [
        'object-basic',
        'object-nullable',
        'object-simple-user',
      ];

      for (final fixtureName in fixtures) {
        final input = loadReferenceFixture(fixtureName);
        final schema = JsonSchema.fromJson(input);
        final output = schema.toJson();

        // The output should be a valid JSON Schema that can be re-parsed
        expect(
          () => JsonSchema.fromJson(output),
          returnsNormally,
          reason: 'Failed to round-trip $fixtureName',
        );
      }
    });
  });
}

/// Normalizes Zod fixtures by removing JavaScript-specific constraints.
Map<String, Object?> normalizeZodFixture(Map<String, Object?> zodSchema) {
  final normalized = Map<String, Object?>.from(zodSchema);

  // Remove $schema field if present
  normalized.remove('\$schema');

  // Helper to remove JS safe bounds
  void removeSafeBounds(Map<String, Object?> schema) {
    if (schema['type'] == 'integer') {
      if (schema['minimum'] == -9007199254740991) {
        schema.remove('minimum');
      }
      if (schema['maximum'] == 9007199254740991) {
        schema.remove('maximum');
      }
    }
  }

  removeSafeBounds(normalized);

  // Handle anyOf patterns
  if (normalized['anyOf'] is List) {
    final anyOf = normalized['anyOf'] as List;
    for (var i = 0; i < anyOf.length; i++) {
      final option = anyOf[i];
      if (option is Map<String, Object?>) {
        anyOf[i] = normalizeZodFixture(option);
      }
    }
  }

  // Handle array item schemas
  if (normalized['items'] is Map<String, Object?>) {
    normalized['items'] = normalizeZodFixture(
      normalized['items'] as Map<String, Object?>,
    );
  }

  // Handle object property schemas
  if (normalized['properties'] is Map<String, Object?>) {
    final props = normalized['properties'] as Map<String, Object?>;
    props.forEach((key, value) {
      if (value is Map<String, Object?>) {
        props[key] = normalizeZodFixture(value);
      }
    });
  }

  return normalized;
}

/// Loads a reference JSON Schema fixture generated by Zod.
Map<String, Object?> loadReferenceFixture(String name) {
  final currentDir = Directory.current.path;
  final projectRoot = currentDir.endsWith('/packages/ack')
      ? currentDir.substring(0, currentDir.length - '/packages/ack'.length)
      : currentDir;
  final fixturePath =
      '$projectRoot/tools/test-fixtures/reference-schemas/$name.json';
  final file = File(fixturePath);

  if (!file.existsSync()) {
    throw Exception(
      'Reference fixture not found: $fixturePath\n'
      'Make sure to run: npm run fixtures (from tools/ directory)',
    );
  }

  final content = file.readAsStringSync();
  final zodSchema = jsonDecode(content) as Map<String, Object?>;

  return normalizeZodFixture(zodSchema);
}
