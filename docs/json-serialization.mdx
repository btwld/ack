---
title: JSON Serialization with Ack
---


This guide shows how to convert between JSON data and Dart objects using Ack.

## From JSON to Dart Objects

### Basic JSON Parsing

```dart
import 'dart:convert';
import 'package:ack/ack.dart';

// 1. Define a schema
final userSchema = Ack.object({
  'name': Ack.string.minLength(2),
  'age': Ack.int.min(0).max(120),
  'email': Ack.string.isEmail().nullable(),
}, required: ['name', 'age']);

// 2. Parse and validate JSON
final jsonString = '{"name": "John", "age": 30, "email": "john@example.com"}';
final jsonMap = jsonDecode(jsonString);
final result = userSchema.validate(jsonMap);

// 3. Use the validated data
if (result.isOk) {
  final validData = result.getOrThrow();
  print('Name: ${validData['name']}');
} else {
  print('Invalid data: ${result.getError()}');
}
```

### Using Generated Schema Models

With code generation, you can work with typed models:

```dart
// 1. Define your model classes
@Schema()
class User {
  final String name;
  final int age;
  final String? email;

  User({required this.name, required this.age, this.email});
}

// 2. Use the generated schema class
final jsonMap = jsonDecode(jsonString);
final userSchema = UserSchema.parse(jsonMap);

// 3. Convert to a typed model
final user = userSchema.toModel();
print('User name: ${user.name}');
```

### Handling Nested Objects

Ack automatically handles nested objects:

```dart
// For custom validation examples, see the Custom Validation page

final orderSchema = Ack.object({
  'id': Ack.string,
  'customer': Ack.object({
    'name': Ack.string,
    'email': Ack.string.isEmail()
  }),
  'items': Ack.list(Ack.object({
    'productId': Ack.string,
    'quantity': Ack.int.min(1),
    'price': Ack.double.min(0.0)
  }))
});

// Later, access nested data
final order = orderSchema.validate(jsonMap).getOrThrow();
final customerName = order['customer']['name'];
final firstItem = order['items'][0];
```

## From Dart Objects to JSON

### Basic Serialization

```dart
// Convert model to schema (for generated classes)
final userSchema = UserSchema.fromModel(user);

// Convert to Map
final jsonMap = userSchema.toMap();

// Convert to JSON string
final jsonString = jsonEncode(jsonMap);
```

### Custom Field Names

Control how your field names appear in JSON:

```dart
@Schema()
class User {
  @JsonKey(name: 'first_name') // Use snake_case in JSON
  final String firstName;      // But camelCase in Dart

  @JsonKey(name: 'last_name')
  final String lastName;

  // This will use the Dart name as-is
  final String email;

  User({required this.firstName, required this.lastName, required this.email});
}
```

This produces:

```json
{
  "first_name": "John",
  "last_name": "Doe",
  "email": "john@example.com"
}
```

### Date/Time Handling

Ack supports DateTime serialization:

```dart
@Schema()
class Event {
  @DateTime() // Mark as DateTime
  final DateTime startTime;

  @DateTime(format: DateTimeFormat.iso8601)
  final DateTime endTime;

  Event({required this.startTime, required this.endTime});
}
```

This serializes to:

```json
{
  "startTime": "2023-12-01T09:00:00.000Z",
  "endTime": "2023-12-01T17:00:00.000Z"
}
```

## Custom Type Converters

For complex types, create custom converters:

```dart
class ColorConverter implements JsonConverter<Color, String> {
  @override
  Color fromJson(String json) {
    return Color(int.parse(json.substring(1), radix: 16));
  }

  @override
  String toJson(Color object) {
    return '#${object.value.toRadixString(16).padLeft(8, '0')}';
  }
}

@Schema()
class Theme {
  @CustomConverter(converter: ColorConverter())
  final Color primaryColor;

  Theme({required this.primaryColor});
}
```

## Error Handling with SchemaResult

Every call to `.validate(value)` returns a `SchemaResult<T>` object, which is either `Ok<T>` or `Fail<T>`:

```dart
final result = userSchema.validate(data);

if (result.isOk) {
  // Success case
  final validData = result.getOrThrow();
  // or
  final validDataOrDefault = result.getOrElse(() => defaultValue);
} else {
  // Error case
  final error = result.getError();
  print('Error: ${error.message}');
  print('Path: ${error.path}');
}
```

## OpenAPI Schema Generation

Ack can generate OpenAPI schema definitions from your schemas:

```dart
final schema = Ack.object({
  'name': Ack.string
    .minLength(2)
    .maxLength(50),
  'age': Ack.int
    .min(0)
    .max(120),
}, required: ['name', 'age']);

final converter = OpenApiSchemaConverter(schema: schema);
final openApiSchema = converter.toSchema();

print(openApiSchema);

/* Returns schema like:
{
  "type": "object",
  "required": ["name", "age"],
  "properties": {
    "name": {
      "type": "string",
      "minLength": 2,
      "maxLength": 50
    },
    "age": {
      "type": "integer",
      "minimum": 0,
      "maximum": 120
    }
  }
}
*/
```

### Working with LLM Responses

When working with LLMs that can generate JSON, you can use Ack to validate their responses:

```dart
final schema = Ack.object({
  'name': Ack.string.minLength(2).maxLength(50),
  'age': Ack.int.min(0).max(120),
}, required: ['name', 'age']);

final converter = OpenApiSchemaConverter(schema: schema);

// Generate a prompt that includes the schema
final prompt = converter.toResponsePrompt();
// Send this prompt to the LLM

// Simulated LLM response
final llmResponse = '''
Here is the person's information:
<response>
{
  "name": "John Smith",
  "age": 35
}
</response>
''';

// Parse and validate the response
final jsonPayload = converter.parseResponse(llmResponse);

print(jsonPayload); // {"name": "John Smith", "age": 35}
```

## Best Practices

1. **Validate Early**: Validate JSON data as soon as it's received, before passing it to the rest of your application.
2. **Use Typed Models**: When possible, use code generation to create typed models for better type safety.
3. **Handle Errors Gracefully**: Always check `result.isOk` before accessing data, and provide meaningful error messages.
4. **Set Appropriate Constraints**: Use constraints like `min`, `maxLength`, and `isEmail` to ensure data quality.
5. **Use Custom Constraints**: Create custom constraints for domain-specific validation rules.
