---
title: Form Validation with Ack
---

This guide shows how to use Ack for validating forms in Flutter applications.

## Basic Form Validation

Here's how you might use Ack to validate a sign-up form in a Flutter application:

```dart
import 'package:ack/ack.dart';
import 'package:flutter/material.dart';

class SignUpForm extends StatefulWidget {
  @override
  _SignUpFormState createState() => _SignUpFormState();
}

class _SignUpFormState extends State<SignUpForm> {
  final _formKey = GlobalKey<FormState>();
  final _usernameController = TextEditingController();
  final _emailController = TextEditingController();
  final _passwordController = TextEditingController();

  // Define schemas
  final _usernameSchema = Ack.string
    .minLength(3)
    .maxLength(20)
    .matches(r'^[a-zA-Z0-9_]+$') // Alphanumeric with underscore
    .isNotEmpty();

  final _emailSchema = Ack.string
    .isEmail()
    .isNotEmpty();

  final _passwordSchema = Ack.string
    .minLength(8)
    .matches(r'(?=.*[A-Z])') // Must contain uppercase
    .matches(r'(?=.*[a-z])') // Must contain lowercase
    .matches(r'(?=.*[0-9])') // Must contain digit
    .isNotEmpty();

  @override
  Widget build(BuildContext context) {
    return Form(
      key: _formKey,
      child: Column(
        children: [
          TextFormField(
            controller: _usernameController,
            decoration: InputDecoration(labelText: 'Username'),
            validator: (value) {
              final result = _usernameSchema.validate(value);
              if (!result.isOk) {
                final error = result.getError() as SchemaConstraintsError;
                return error.constraints.first.message;
              }
              return null;
            },
          ),
          TextFormField(
            controller: _emailController,
            decoration: InputDecoration(labelText: 'Email'),
            validator: (value) {
              final result = _emailSchema.validate(value);
              if (!result.isOk) {
                final error = result.getError() as SchemaConstraintsError;
                return error.constraints.first.message;
              }
              return null;
            },
          ),
          TextFormField(
            controller: _passwordController,
            decoration: InputDecoration(labelText: 'Password'),
            obscureText: true,
            validator: (value) {
              final result = _passwordSchema.validate(value);
              if (!result.isOk) {
                final error = result.getError() as SchemaConstraintsError;
                return error.constraints.first.message;
              }
              return null;
            },
          ),
          ElevatedButton(
            onPressed: () {
              if (_formKey.currentState!.validate()) {
                // Form is valid, proceed with sign up
                print('Form is valid!');
              }
            },
            child: Text('Sign Up'),
          ),
        ],
      ),
    );
  }

  @override
  void dispose() {
    _usernameController.dispose();
    _emailController.dispose();
    _passwordController.dispose();
    super.dispose();
  }
}
```

## Integrating with Form Widgets

Ack integrates seamlessly with Flutter's form widgets:

1. **Define schemas** for each field
2. **Use in validators** to validate input
3. **Extract error messages** from validation results

## Real-time Validation

For real-time validation as the user types:

```dart
class RealtimeValidationForm extends StatefulWidget {
  @override
  _RealtimeValidationFormState createState() => _RealtimeValidationFormState();
}

class _RealtimeValidationFormState extends State<RealtimeValidationForm> {
  final _emailController = TextEditingController();
  String? _emailError;

  final _emailSchema = Ack.string.isEmail();

  @override
  void initState() {
    super.initState();
    _emailController.addListener(_validateEmail);
  }

  void _validateEmail() {
    final result = _emailSchema.validate(_emailController.text);
    setState(() {
      if (!result.isOk && _emailController.text.isNotEmpty) {
        final error = result.getError() as SchemaConstraintsError;
        _emailError = error.constraints.first.message;
      } else {
        _emailError = null;
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        TextField(
          controller: _emailController,
          decoration: InputDecoration(
            labelText: 'Email',
            errorText: _emailError,
          ),
        ),
      ],
    );
  }

  @override
  void dispose() {
    _emailController.removeListener(_validateEmail);
    _emailController.dispose();
    super.dispose();
  }
}
```

## Form Submission

When submitting forms, you can validate all fields at once:

```dart
void _submitForm() {
  // Validate all fields
  final usernameResult = _usernameSchema.validate(_usernameController.text);
  final emailResult = _emailSchema.validate(_emailController.text);
  final passwordResult = _passwordSchema.validate(_passwordController.text);

  // Check if all validations passed
  if (usernameResult.isOk && emailResult.isOk && passwordResult.isOk) {
    // Proceed with form submission
    final userData = {
      'username': _usernameController.text,
      'email': _emailController.text,
      'password': _passwordController.text,
    };

    // Submit data
    _userService.createUser(userData);
  } else {
    // Show error messages
    setState(() {
      // Update error state for each field
    });
  }
}
```

## Using with SchemaModel

For more complex forms, you can use SchemaModel to validate the entire form at once:

```dart
@Schema()
class UserFormData {
  @MinLength(3)
  @MaxLength(20)
  final String username;

  @IsEmail()
  final String email;

  @MinLength(8)
  final String password;

  UserFormData({
    required this.username,
    required this.email,
    required this.password,
  });
}

// In your form submission
void _submitForm() {
  try {
    final formData = UserFormData(
      username: _usernameController.text,
      email: _emailController.text,
      password: _passwordController.text,
    );

    // Validate using generated schema
    final result = UserFormDataSchema.fromModel(formData).validate();

    if (result.isOk) {
      // Form is valid, proceed
    } else {
      // Handle validation errors
    }
  } catch (e) {
    // Handle exceptions
  }
}
```

## Best Practices

1. **Define schemas once** and reuse them across your app
2. **Provide clear error messages** that help users fix issues
3. **Validate in real-time** for better user experience
4. **Use SchemaModel** for complex forms with many fields
5. **Handle all validation states** (valid, invalid, loading)

By following these patterns, you can create robust form validation in your Flutter applications that provides a great user experience while ensuring data integrity.
