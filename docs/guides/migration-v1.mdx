---
title: Migrating to Ack v1.0
---

Ack v1.0 introduces a significant architectural change that simplifies the library and makes it more focused. This guide helps you migrate your code from v0.x to v1.0.

## What Changed

Ack v1.0 removes the `SchemaModel` generation feature. The `ack_generator` package now focuses exclusively on generating schema variables for validation. This change streamlines the library and gives you more control over your model layer.

**Key Changes:**

- **Removed:** `model` parameter from `@AckModel` annotation
- **Removed:** `SchemaModel` base class
- **Removed:** SchemaModel class generation (for example, `UserSchemaModel`)
- **Kept:** All validation features, discriminated types, additional properties, and constraint annotations
- **Kept:** Schema generation from `@AckModel` annotated classes

## Why This Change

The v1.0 architecture provides several benefits:

- **Simpler mental model:** Validation is separate from serialization
- **More flexibility:** Choose your own serialization patterns (manual, `json_serializable`, `freezed`, `dart_mappable`, etc.)
- **Smaller generated code:** Only schema variables are generated
- **Better tree-shaking:** Less unused code in your final bundle
- **Clearer responsibilities:** Ack focuses on validation, you control models

## Migration Checklist

Follow these steps to migrate your project:

- [ ] Update `@AckModel` annotations (remove `model: true` parameter)
- [ ] Run `melos build` to regenerate code
- [ ] Update validation code to use `parse()` or `safeParse()` directly on schemas
- [ ] Choose how to work with validated data (direct map access, manual constructors, or serialization libraries)
- [ ] Run tests to verify everything works
- [ ] Update any documentation or comments

## Before and After Examples

### Simple Model

**Before (v0.x):**

```dart
import 'package:ack/ack.dart';
import 'package:ack_annotations/ack_annotations.dart';

part 'user.g.dart';

@AckModel(model: true)
class User {
  final String name;
  final String email;
  final int age;

  User({
    required this.name,
    required this.email,
    required this.age,
  });
}

// Usage - SchemaModel provided validation and deserialization
void main() {
  final userData = {
    'name': 'Alice',
    'email': 'alice@example.com',
    'age': 30,
  };

  final userModel = UserSchemaModel();
  final result = userModel.parse(userData);

  if (result.isOk) {
    final user = userModel.value!; // Type-safe User instance
    print('User: ${user.name}, ${user.email}, ${user.age}');
  }
}
```

**After (v1.0):**

```dart
import 'package:ack/ack.dart';
import 'package:ack_annotations/ack_annotations.dart';

part 'user.g.dart';

@AckModel()
class User {
  final String name;
  final String email;
  final int age;

  User({
    required this.name,
    required this.email,
    required this.age,
  });
}

// Usage - Schema validates, you work with validated map
void main() {
  final userData = {
    'name': 'Alice',
    'email': 'alice@example.com',
    'age': 30,
  };

  // userSchema is generated by ack_generator
  final result = userSchema.safeParse(userData);

  if (result.isOk) {
    final validData = result.getOrThrow();

    // Option 1: Work with the validated map directly
    print('Name: ${validData['name']}');

    // Option 2: Create model instance manually
    final user = User(
      name: validData['name'] as String,
      email: validData['email'] as String,
      age: validData['age'] as int,
    );
    print('User: ${user.name}, ${user.email}, ${user.age}');
  }
}
```

> **Note:** In v0.x, `SchemaModel` provided `.createFromMap()` for you. In v1.0, you work with the validated `Map<String, dynamic>` directly. You can access values from the map, create model instances manually, or use any serialization library you prefer (`json_serializable`, `freezed`, etc.). Ack focuses only on validation.

### Nested Models

**Before (v0.x):**

```dart
@AckModel(model: true)
class Address {
  final String street;
  final String city;
  final String zipCode;

  Address({
    required this.street,
    required this.city,
    required this.zipCode,
  });
}

@AckModel(model: true)
class Person {
  final String name;
  final Address address;

  Person({
    required this.name,
    required this.address,
  });
}

// Usage
final personData = {
  'name': 'Bob',
  'address': {
    'street': '123 Main St',
    'city': 'Springfield',
    'zipCode': '12345',
  },
};

final personModel = PersonSchemaModel();
final result = personModel.parse(personData);
if (result.isOk) {
  final person = personModel.value!;
  print('${person.name} lives at ${person.address.street}');
}
```

**After (v1.0):**

```dart
@AckModel()
class Address {
  final String street;
  final String city;
  final String zipCode;

  Address({
    required this.street,
    required this.city,
    required this.zipCode,
  });
}

@AckModel()
class Person {
  final String name;
  final Address address;

  Person({
    required this.name,
    required this.address,
  });
}

// Usage
final personData = {
  'name': 'Bob',
  'address': {
    'street': '123 Main St',
    'city': 'Springfield',
    'zipCode': '12345',
  },
};

final result = personSchema.safeParse(personData);
if (result.isOk) {
  final validData = result.getOrThrow();

  // Option 1: Access nested data from validated map
  final name = validData['name'] as String;
  final addressData = validData['address'] as Map<String, dynamic>;
  final street = addressData['street'] as String;
  print('$name lives at $street');

  // Option 2: Build model instances manually
  final address = Address(
    street: addressData['street'] as String,
    city: addressData['city'] as String,
    zipCode: addressData['zipCode'] as String,
  );
  final person = Person(name: name, address: address);
  print('${person.name} lives at ${person.address.street}');
}
```

> **Note:** With nested models, you have the same flexibility. Access nested map data directly, build objects manually, or add helper methods (like `fromMap()` factories) if you prefer. Choose the pattern that fits your codebase.

### Discriminated Types

**Before (v0.x):**

```dart
@AckModel(discriminatedKey: 'type', model: true)
abstract class Animal {
  String get type;
}

@AckModel(discriminatedValue: 'cat', model: true)
class Cat extends Animal {
  @override
  String get type => 'cat';

  final bool meow;
  final int lives;

  Cat({required this.meow, this.lives = 9});
}

@AckModel(discriminatedValue: 'dog', model: true)
class Dog extends Animal {
  @override
  String get type => 'dog';

  final bool bark;
  final String breed;

  Dog({required this.bark, required this.breed});
}

// Usage
final animalModel = AnimalSchemaModel();
final result = animalModel.parse({'type': 'cat', 'meow': true, 'lives': 9});
if (result.isOk) {
  final animal = animalModel.value!; // Typed Animal instance
  if (animal is Cat) {
    print('Cat with ${animal.lives} lives');
  }
}
```

**After (v1.0):**

```dart
@AckModel(discriminatedKey: 'type')
abstract class Animal {
  String get type;
}

@AckModel(discriminatedValue: 'cat')
class Cat extends Animal {
  @override
  String get type => 'cat';

  final bool meow;
  final int lives;

  Cat({required this.meow, this.lives = 9});
}

@AckModel(discriminatedValue: 'dog')
class Dog extends Animal {
  @override
  String get type => 'dog';

  final bool bark;
  final String breed;

  Dog({required this.bark, required this.breed});
}

// Usage
final result = animalSchema.safeParse({'type': 'cat', 'meow': true, 'lives': 9});
if (result.isOk) {
  final validData = result.getOrThrow();

  // Option 1: Work with discriminated map directly
  final type = validData['type'] as String;
  if (type == 'cat') {
    final meow = validData['meow'] as bool;
    final lives = validData['lives'] as int? ?? 9;
    print('Cat that ${meow ? 'meows' : 'is silent'} with $lives lives');
  }

  // Option 2: Build type-specific instances manually
  Animal animal;
  switch (type) {
    case 'cat':
      animal = Cat(
        meow: validData['meow'] as bool,
        lives: validData['lives'] as int? ?? 9,
      );
    case 'dog':
      animal = Dog(
        bark: validData['bark'] as bool,
        breed: validData['breed'] as String,
      );
    default:
      throw ArgumentError('Unknown animal type: $type');
  }

  if (animal is Cat) {
    print('Cat with ${animal.lives} lives');
  }
}
```

> **Note:** Discriminated types work the same way. The validated map contains the type discriminator. You can pattern match on it, build instances manually, or add helper factories if that suits your style.

## Common Migration Scenarios

### API Request Validation

**Before (v0.x):**

```dart
Future<User> fetchUser(String userId) async {
  final response = await http.get(Uri.parse('/api/users/$userId'));
  final jsonData = jsonDecode(response.body);

  final userModel = UserSchemaModel();
  final result = userModel.parse(jsonData);

  if (result.isOk) {
    return userModel.value!;
  } else {
    throw Exception('Invalid user data: ${result.getError()}');
  }
}
```

**After (v1.0):**

```dart
Future<User> fetchUser(String userId) async {
  final response = await http.get(Uri.parse('/api/users/$userId'));
  final jsonData = jsonDecode(response.body);

  final result = userSchema.safeParse(jsonData);

  if (result.isOk) {
    final validData = result.getOrThrow();
    // Build User instance from validated map
    return User(
      name: validData['name'] as String,
      email: validData['email'] as String,
      age: validData['age'] as int,
    );
  } else {
    throw Exception('Invalid user data: ${result.getError()}');
  }
}
```

### Configuration File Parsing

**Before (v0.x):**

```dart
@AckModel(model: true)
class AppConfig {
  final String apiUrl;
  final int timeout;
  final bool debugMode;

  AppConfig({
    required this.apiUrl,
    required this.timeout,
    this.debugMode = false,
  });
}

Future<AppConfig> loadConfig() async {
  final file = File('config.json');
  final jsonString = await file.readAsString();
  final jsonData = jsonDecode(jsonString);

  final configModel = AppConfigSchemaModel();
  final result = configModel.parse(jsonData);

  if (result.isOk) {
    return configModel.value!;
  } else {
    throw Exception('Invalid config: ${result.getError()}');
  }
}
```

**After (v1.0):**

```dart
@AckModel()
class AppConfig {
  final String apiUrl;
  final int timeout;
  final bool debugMode;

  AppConfig({
    required this.apiUrl,
    required this.timeout,
    this.debugMode = false,
  });
}

Future<AppConfig> loadConfig() async {
  final file = File('config.json');
  final jsonString = await file.readAsString();
  final jsonData = jsonDecode(jsonString);

  final result = appConfigSchema.safeParse(jsonData);

  if (result.isOk) {
    final validData = result.getOrThrow();
    return AppConfig(
      apiUrl: validData['apiUrl'] as String,
      timeout: validData['timeout'] as int,
      debugMode: validData['debugMode'] as bool? ?? false,
    );
  } else {
    throw Exception('Invalid config: ${result.getError()}');
  }
}
```

### Form Data Validation

**Before (v0.x):**

```dart
@AckModel(model: true)
class SignupForm {
  @MinLength(3)
  final String username;

  @Email()
  final String email;

  @MinLength(8)
  final String password;

  SignupForm({
    required this.username,
    required this.email,
    required this.password,
  });
}

void handleSignup(Map<String, dynamic> formData) {
  final formModel = SignupFormSchemaModel();
  final result = formModel.parse(formData);

  if (result.isOk) {
    final form = formModel.value!;
    createAccount(form.username, form.email, form.password);
  } else {
    showErrors(result.getError());
  }
}
```

**After (v1.0):**

```dart
@AckModel()
class SignupForm {
  @MinLength(3)
  final String username;

  @Email()
  final String email;

  @MinLength(8)
  final String password;

  SignupForm({
    required this.username,
    required this.email,
    required this.password,
  });
}

void handleSignup(Map<String, dynamic> formData) {
  final result = signupFormSchema.safeParse(formData);

  if (result.isOk) {
    final validData = result.getOrThrow();

    // Option 1: Pass validated values directly
    createAccount(
      validData['username'] as String,
      validData['email'] as String,
      validData['password'] as String,
    );

    // Option 2: Create form object if needed
    final form = SignupForm(
      username: validData['username'] as String,
      email: validData['email'] as String,
      password: validData['password'] as String,
    );
    createAccount(form.username, form.email, form.password);
  } else {
    showErrors(result.getError());
  }
}
```

## Benefits of v1.0

Migrating to v1.0 brings several advantages:

### Simpler Mental Model

Ack focuses on what it does best: validation. Serialization is your responsibility, which means:

- Clear separation of concerns
- Validation logic is independent from model construction
- Easier to reason about data flow

### More Flexibility

You're no longer locked into a specific pattern. After validation, you can:

- Work directly with the validated `Map<String, dynamic>`
- Build model instances manually using constructors
- Add your own `fromMap()` or `fromJson()` factory methods
- Use `json_serializable` for code generation
- Use `freezed` for immutable models
- Use `dart_mappable` for advanced serialization
- Mix and match approaches per use case

Ack validates the data structure and types. You decide how to use the validated data.

### Smaller Generated Code

The generator creates only schema variables, not full SchemaModel classes. This results in:

- Faster build times
- Smaller generated files
- Less code to maintain
- Better IDE performance

### Better Tree-Shaking

With separate validation and serialization:

- Unused validation schemas can be tree-shaken
- Your model classes remain lightweight
- Final bundle size is reduced

### Integration with Other Tools

You can easily combine Ack with other packages:

```dart
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:ack_annotations/ack_annotations.dart';

part 'user.freezed.dart';
part 'user.g.dart'; // Ack schema generation

@freezed
@AckModel()
class User with _$User {
  const factory User({
    required String name,
    required String email,
    required int age,
  }) = _User;

  factory User.fromJson(Map<String, dynamic> json) => _$UserFromJson(json);
}

// Validate with Ack, serialize with Freezed
void processUser(Map<String, dynamic> data) {
  final result = userSchema.safeParse(data);
  if (result.isOk) {
    final user = User.fromJson(result.getOrThrow());
    print('User: ${user.name}');
  }
}
```

## Working with Validated Data

After migration, you choose how to work with validated data. Here are some common patterns:

### Direct Map Access

The simplest approach is working directly with the validated map:

```dart
@AckModel()
class Product {
  final String id;
  final String name;
  final double price;

  Product({
    required this.id,
    required this.name,
    required this.price,
  });
}

// Usage
final result = productSchema.safeParse(data);
if (result.isOk) {
  final validData = result.getOrThrow();

  // Access values directly
  final id = validData['id'] as String;
  final name = validData['name'] as String;
  final price = (validData['price'] as num).toDouble();

  print('Product $id: $name costs \$$price');
}
```

### Manual Model Construction

Build model instances when you need structured data:

```dart
final result = productSchema.safeParse(data);
if (result.isOk) {
  final validData = result.getOrThrow();

  final product = Product(
    id: validData['id'] as String,
    name: validData['name'] as String,
    price: (validData['price'] as num).toDouble(),
  );

  saveProduct(product);
}
```

### Optional Helper Factories

Add factory methods if you prefer a consistent pattern across your codebase:

```dart
@AckModel()
class Product {
  final String id;
  final String name;
  final double price;

  Product({
    required this.id,
    required this.name,
    required this.price,
  });

  // Optional: Add helper if you use this pattern often
  factory Product.fromMap(Map<String, dynamic> map) {
    return Product(
      id: map['id'] as String,
      name: map['name'] as String,
      price: (map['price'] as num).toDouble(),
    );
  }
}

// Usage
final result = productSchema.safeParse(data);
if (result.isOk) {
  final product = Product.fromMap(result.getOrThrow());
}
```

### Integration with Serialization Libraries

Ack works seamlessly with popular serialization packages:

```dart
import 'package:json_annotation/json_annotation.dart';
import 'package:ack_annotations/ack_annotations.dart';

part 'product.g.dart';

@JsonSerializable()
@AckModel()
class Product {
  final String id;
  final String name;
  final double price;

  Product({
    required this.id,
    required this.name,
    required this.price,
  });

  factory Product.fromJson(Map<String, dynamic> json) =>
      _$ProductFromJson(json);

  Map<String, dynamic> toJson() => _$ProductToJson(this);
}

// Validate with Ack, serialize with json_serializable
final result = productSchema.safeParse(data);
if (result.isOk) {
  final product = Product.fromJson(result.getOrThrow());
}
```

> **Remember:** These are just examples. Choose the approach that fits your project. The key change in v1.0 is that Ack gives you a validated map and gets out of your way.

## Troubleshooting

### Error: "The getter 'value' isn't defined"

This error occurs when trying to access `.value` on a schema, which no longer exists in v1.0.

**Solution:** Use `safeParse()` or `parse()` directly on the schema, then work with the validated map:

```dart
// ❌ Old way - doesn't work in v1.0
final userModel = UserSchemaModel();
final result = userModel.parse(data);
final user = userModel.value!;

// ✅ New way - work with validated map
final result = userSchema.safeParse(data);
if (result.isOk) {
  final validData = result.getOrThrow();

  // Access map values directly
  final name = validData['name'] as String;

  // Or build a model instance
  final user = User(
    name: validData['name'] as String,
    email: validData['email'] as String,
    age: validData['age'] as int,
  );
}
```

### Error: "Undefined name 'UserSchemaModel'"

SchemaModel classes are no longer generated in v1.0.

**Solution:** Use the generated schema variable directly (lowercase, ends with `Schema`):

```dart
// ❌ Old way - SchemaModel class
final userModel = UserSchemaModel();

// ✅ New way - schema variable
final result = userSchema.safeParse(data);
```

### Build Errors After Updating

If you see build errors after updating, regenerate your code:

```bash
# Clean old generated files
melos clean

# Bootstrap dependencies
melos bs

# Regenerate code
melos build
```

### Type Cast Errors

If you access validated map values without proper casting, you may get type errors at runtime.

**Solution:** Always cast values when extracting from the validated map:

```dart
final result = productSchema.safeParse(data);
if (result.isOk) {
  final validData = result.getOrThrow();

  // ❌ Type mismatch - no cast
  final price = validData['price']; // Type: dynamic

  // ✅ Proper cast
  final price = validData['price'] as double;

  // ✅ Safe cast for nullable values
  final discount = validData['discount'] as double?;
}
```

Remember: Ack validates that the data structure and types are correct, so these casts are safe after successful validation.

## Getting Help

If you encounter issues during migration:

- Check the [GitHub Issues](https://github.com/btwld/ack/issues) for similar problems
- Review the [documentation](https://ack.btwld.dev) for updated examples
- Open a new issue if you find a bug or need clarification

The migration to v1.0 requires some refactoring, but the result is a simpler, more flexible validation library that integrates smoothly with your existing tools and patterns.
