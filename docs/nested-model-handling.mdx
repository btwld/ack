---
title: Working with Nested Models in Ack
---


This guide shows how to work with complex nested data structures in Ack.

## Key Concepts

- **Schema-First**: Ack validates data against schemas before creating models
- **Automatic Conversion**: Ack converts nested data to the right model types
- **Type Safety**: All models maintain proper typing throughout the object graph

## Approaches to Nested Models

### 1. Direct Model Access (Recommended)

Access nested models directly through their parent:

```dart
// Parse JSON data
final userData = jsonDecode('{"name": "John", "address": {"city": "New York"}}');

// Validate with schema
final userSchema = UserSchema.parse(userData);

// Convert to model
final user = userSchema.toModel();

// Access nested models directly - no manual conversion needed
final address = user.address; // This is already an Address model
print(address.city); // "New York"
```

### 2. Working with Schemas Directly

Work with schemas when you need advanced validation:

```dart
// Validate the user data
final userSchema = UserSchema.parse(userData);

// Access and validate the address schema separately
final addressSchema = userSchema.address;
final isAddressValid = addressSchema.validate().isOk;

if (isAddressValid) {
  // Convert just the address to a model
  final address = addressSchema.toModel();
  print(address.city);
}
```

### 3. Updating Nested Models

When updating nested data:

```dart
// Get the original model
final user = userSchema.toModel();

// Create an updated version with a modified address
final updatedUser = User(
  id: user.id,
  name: user.name,
  address: Address(
    street: user.address.street,
    city: "Miami", // Changed city
    zipCode: user.address.zipCode
  )
);

// Convert back to schema for validation
final updatedSchema = UserSchema.fromModel(updatedUser);
```

## Working with Lists of Models

For lists of nested models:

```dart
// Parse user data with addresses
final userSchema = UserSchema.parse(userData);
final user = userSchema.toModel();

// Access list of addresses as models
final addresses = user.alternateAddresses; // Already a List<Address>

// Process each address
for (final address in addresses) {
  print(address.city); // Direct access to model properties
}
```

## How It Works

Ack provides automatic model conversion through:

1. **Generated Getters** that convert nested models:

```dart
// Generated code example
@override
Address get address {
  final schema = getValue<AddressSchema>('address');
  if (schema == null) return null;
  return schema.toModel();
}
```

2. **Schema Registry** to track model-schema relationships

3. **SchemaConverter** to handle type conversions

## Example: Complex Nested Structure

```dart
// Define your models
@Schema()
class Order {
  final String id;
  final Customer customer;
  final List<OrderItem> items;
  final Address shippingAddress;
  
  Order({
    required this.id,
    required this.customer,
    required this.items,
    required this.shippingAddress,
  });
}

// Parse JSON order data
final orderData = jsonDecode(orderJsonString);
final orderSchema = OrderSchema.parse(orderData);
final order = orderSchema.toModel();

// Access any level of nesting
final customerName = order.customer.name;
final firstItemPrice = order.items.first.price;
final shippingCity = order.shippingAddress.city;
```

## Best Practices

1. **Use Direct Access**: Access nested models directly through parent models
2. **Validate Early**: Validate data as early as possible
3. **Create Immutable Updates**: Create new models instead of modifying existing ones
4. **Keep Models Simple**: Design models with clear responsibilities
5. **Handle Null Values**: Consider nullable properties for optional nested data 
