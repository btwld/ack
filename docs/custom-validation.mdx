---
title: Custom Validation in Ack
---


This guide shows how to create custom validation rules in Ack.

## Option 1: Combine Built-in Validators

The simplest approach is to chain Ack's built-in validators:

```dart
// Username validation: 3-20 characters, alphanumeric, starts with a letter
final usernameSchema = Ack.string
  .minLength(3)
  .maxLength(20)
  .pattern(r'[a-zA-Z][a-zA-Z0-9]*$');
```

### Using `pattern` and `matches` for Regex Validation

Ack provides two convenient methods for regex validation:

```dart
// Use pattern() when the entire string must match the pattern
final usernameSchema = Ack.string.pattern(r'[a-zA-Z0-9_]+');

// Use matches() when the string should contain a pattern anywhere within it
final passwordSchema = Ack.string
  .minLength(8)
  .matches(r'[A-Z]') // Must contain uppercase
  .matches(r'[a-z]') // Must contain lowercase
  .matches(r'[0-9]') // Must contain digit
  .isNotEmpty();
```

## Option 2: Use the `.custom()` Method

For one-off validation rules, use the `.custom()` method:

```dart
// Validate a price with specific formatting rules
final priceSchema = Ack.double.custom(
  'validMarketPrice',
  (value) => value > 0 && (value * 100).toInt() % 5 == 0,
  message: 'Price must be positive and end in .00 or .50'
);

// Test the schema
final result = priceSchema.validate(24.50); // Valid
final invalid = priceSchema.validate(24.37); // Invalid
```

## Option 3: Create Custom Constraints

For reusable validation rules, create custom constraint classes:

```dart
// Custom constraint for even numbers
class OnlyEvenConstraint extends Constraint<int> with Validator<int> {
  const OnlyEvenConstraint()
      : super(
          constraintKey: 'only_even',
          description: 'Must be an even number',
        );

  @override
  bool isValid(int value) => value % 2 == 0;

  @override
  String buildMessage(int value) => 'Value must be an even number.';
}

// Using your custom validator
final evenNumberSchema = Ack.int
  .constrain(OnlyEvenConstraint())
  .min(0)
  .max(100);
```

## Option 4: Create Reusable Validators as Extensions

For validators you'll use across your app, create extensions:

```dart
// Create a credit card validator extension
extension CreditCardValidator on StringSchema {
  StringSchema isCreditCard() {
    return custom(
      'isCreditCard',
      (value) => _validateCreditCard(value),
      message: 'Must be a valid credit card number'
    );
  }

  bool _validateCreditCard(String? value) {
    // Luhn algorithm implementation
    if (value == null) return false;

    // Remove spaces and dashes
    final sanitized = value.replaceAll(RegExp(r'[\s-]'), '');

    // Basic format check
    if (!RegExp(r'^[0-9]{13,19}$').hasMatch(sanitized)) return false;

    // Luhn algorithm check
    int sum = 0;
    bool alternate = false;
    for (int i = sanitized.length - 1; i >= 0; i--) {
      int digit = int.parse(sanitized[i]);
      if (alternate) {
        digit *= 2;
        if (digit > 9) digit -= 9;
      }
      sum += digit;
      alternate = !alternate;
    }
    return sum % 10 == 0;
  }
}

// Usage
final schema = Ack.string.isCreditCard();
```

## Cross-Field Validation

Validate fields that depend on each other by overriding the `validate` method:

```dart
class PaymentDetailsSchema extends SchemaModel<PaymentDetails> {
  @override
  SchemaResult validate() {
    // First run the standard validation
    final result = schema.validate(toMap());
    if (result.isFail) return result;

    // Now add custom cross-field validation
    final expiryMonth = getValue<int>('expiryMonth')!;
    final expiryYear = getValue<int>('expiryYear')!;

    // Check if card is expired
    final now = DateTime.now();
    if (expiryYear < now.year ||
       (expiryYear == now.year && expiryMonth < now.month)) {
      return SchemaResult.fail({
        'expiry': 'Card has expired'
      });
    }

    return SchemaResult.ok(toMap());
  }
}
```

## Custom Error Messages

Make error messages clear and specific:

```dart
final passwordSchema = Ack.string.minLength(
  8,
  message: 'Password must be at least 8 characters long'
);

// Or in schema models with annotations
@Schema()
class User {
  @MinLength(8)
  @Description(text: 'Password must be at least 8 characters')
  final String password;

  User({required this.password});
}
```

## Async Validation

For validation that requires database lookups or API calls:

```dart
// First validate with schema
final result = UserSchema.validateMap(userData);
if (result.isFail) return result;

// Then do async validation
Future<SchemaResult> validateUserAsync(Map<String, dynamic> userData) async {
  final email = userData['email'] as String;

  // Check if email is already in use
  final isEmailTaken = await userRepository.isEmailInUse(email);
  if (isEmailTaken) {
    return SchemaResult.fail({
      'email': 'This email is already in use'
    });
  }

  return SchemaResult.ok(userData);
}
```

## Advanced Custom Constraints

For more complex validation scenarios, you can create constraints with additional features:

```dart
// Note: For most regex validation needs, use the built-in pattern() and matches() methods
// This custom constraint is only needed for more complex regex validation scenarios

// Custom constraint for regex pattern matching
class StringRegexConstraint extends Constraint<String> with Validator<String> {
  final String patternName;
  final String pattern;
  final String example;
  late final RegExp _regex;

  StringRegexConstraint({
    required this.patternName,
    required this.pattern,
    required this.example,
  }) : super(
          constraintKey: 'regex_$patternName',
          description: 'Must match pattern: $pattern',
        ) {
    _regex = RegExp(pattern);
  }

  @override
  bool isValid(String value) => _regex.hasMatch(value);

  @override
  String buildMessage(String value) =>
      'Value must match $patternName pattern (e.g., $example)';
}

// Custom constraint for email validation with preprocessing
class TrimmedEmailConstraint extends Constraint<String> with Validator<String> {
  const TrimmedEmailConstraint()
      : super(
          constraintKey: 'trimmed_email',
          description: 'Must be a valid email address',
        );

  @override
  bool isValid(String value) {
    // Trim the value before validation
    final trimmed = value.trim();
    // Simple email validation regex
    final regex = RegExp(r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$');
    return regex.hasMatch(trimmed);
  }

  @override
  String buildMessage(String value) => 'Value must be a valid email address';
}

// Custom constraint with parameters
class AgeConstraint extends Constraint<int> with Validator<int> {
  final int minAge;

  const AgeConstraint(this.minAge)
      : super(
          constraintKey: 'min_age',
          description: 'Must be at least $minAge years old',
        );

  @override
  bool isValid(int value) => value >= minAge;

  @override
  String buildMessage(int value) => 'You must be at least $minAge years old';
}
```

## Best Practices

1. Start with built-in validators when possible
   - Use `pattern()` for validating entire string formats
   - Use `matches()` for checking if a string contains specific patterns
2. Create reusable validators for common patterns
3. Use clear, specific error messages
4. Validate at the right level (field vs. cross-field)
5. Keep custom validators simple and focused
6. Use custom constraints only for complex validation logic
7. Create constraint instances as constants when possible
