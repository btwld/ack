# Ack 0.2.0 Feature Examples

This document provides comprehensive examples of all the new features introduced in Ack 0.2.0, including code generation and automatic property inference.

## Code Generation with Annotations

The following example demonstrates all the major features of Ack's code generation with automatic inference:

```dart
// file: user.dart
import 'package:ack_generator/ack_generator.dart';

part 'user.g.dart';

// Simple enum for roles
enum UserRole { admin, user, moderator }

// Nested model with its own validation
@Schema()
class Profile {
  @MinLength(1)
  final String firstName;
  
  @MinLength(1)
  final String lastName;
  
  @MaxLength(500)
  final String? bio;
  
  Profile({
    required this.firstName,
    required this.lastName,
    this.bio,
  });
  
  factory Profile.fromSchema(ProfileSchema schema) {
    return Profile(
      firstName: schema.firstName,
      lastName: schema.lastName,
      bio: schema.bio,
    );
  }
}

// Main user model with comprehensive validation and automatic inference
@Schema(
  description: 'A user account with profile information',
  additionalProperties: true,
  additionalPropertiesField: 'metadata'
)
class User {
  @MinLength(3)
  @MaxLength(20)
  @Pattern(r'^[a-zA-Z0-9_]+$')
  final String username;

  @IsEmail()
  final String email;

  @Min(13)
  @Max(120)
  final int age;

  @DefaultValue(true)
  final bool isActive;

  @UniqueItems()
  final List<UserRole> roles;

  final Profile profile;

  @MaxItems(10)
  final List<String>? tags;

  @MinLength(8)
  @Pattern(r'^(?=.*[A-Za-z])(?=.*\d)')
  final String? password;

  final Map<String, dynamic> metadata;

  User({
    required this.username,
    required this.email,
    required this.age,
    this.isActive = true,
    required this.roles,
    required this.profile,
    this.tags,
    this.password,
    Map<String, dynamic>? metadata,
  }) : metadata = metadata ?? {};
  
  factory User.fromSchema(UserSchema schema) {
    return User(
      username: schema.username,
      email: schema.email,
      age: schema.age,
      isActive: schema.isActive,
      roles: schema.roles,
      profile: Profile.fromSchema(schema.profile),
      tags: schema.tags,
      password: schema.password,
      metadata: schema.metadata,
    );
  }
}
```

## Automatic Inference in Action

With automatic inference, Ack determines:
- **Required fields** from `required` constructor parameters
- **Optional fields** from optional constructor parameters
- **Nullable fields** from nullable types (e.g., `String?`)
- **Non-nullable fields** from non-nullable types (e.g., `String`)

No need for `@Required()` or `@Nullable()` annotations unless you want to override the default behavior!

## Working with Generated Schemas

```dart
// file: main.dart
import 'dart:convert';
import 'user.dart';
import 'user.schema.dart'; // Import the generated file

void main() {
  // 1. Create test data
  final userData = {
    'username': 'john_doe',
    'email': 'john@example.com',
    'age': 25,
    'isActive': true,
    'roles': ['user', 'moderator'],
    'profile': {
      'firstName': 'John',
      'lastName': 'Doe',
      'bio': 'Software developer'
    },
    'tags': ['flutter', 'dart', 'mobile'],
    'password': 'SecurePass123',
    // Additional properties captured by metadata
    'lastLogin': '2023-01-15T10:30:00Z',
    'preferences': {
      'theme': 'dark',
      'notifications': true
    }
  };

  // 2. Create schema instance (validation happens automatically)
  final userSchema = UserSchema(userData);

  // 3. Check validation and access properties
  if (!userSchema.isValid) {
    final errors = userSchema.getErrors();
    print('Validation failed:');
    print('- Error name: ${errors?.name}');
    print('- Error message: ${errors?.message}');
    print('- Error path: ${errors?.path}');
  }

  // 4. Access validated data through typed getters
  if (userSchema.isValid) {
    // Direct property access
    print('User: ${userSchema.username}, Email: ${userSchema.email}');
    print('Name: ${userSchema.profile.firstName} ${userSchema.profile.lastName}');

    // Access additional properties via metadata
    print('Last Login: ${userSchema.metadata['lastLogin']}');
    print('Theme Preference: ${userSchema.metadata['preferences']['theme']}');
    
    // Create model when needed
    final user = User.fromSchema(userSchema);
    print('Created user model: ${user.username}');
  }

  // 5. Create model and convert to schema
  final userModelInstance = User(
    username: 'jane_smith',
    email: 'jane@example.com',
    age: 28,
    isActive: true,
    roles: [UserRole.user],
    profile: Profile(
      firstName: 'Jane',
      lastName: 'Smith',
      bio: 'Product manager'
    ),
    metadata: {
      'lastLogin': '2023-02-15T09:30:00Z',
      'preferences': {'theme': 'light', 'notifications': false}
    }
  );

  // Create schema from model data using toMap()
  final userMap = userModelInstance.toMap();
  final userSchemaInstance = UserSchema(userMap);

  // Convert to JSON
  final userJson = jsonEncode(userSchemaInstance.toMap());
  print('User JSON: $userJson');

  // 6. Generate JSON Schema
  final jsonSchema = UserSchema.toJsonSchema();
  final jsonString = jsonEncode(jsonSchema);
  print('JSON Schema: $jsonString');
}
```

## String Validation Improvements

### Email Validation
```dart
@Schema()
class Contact {
  @IsEmail()
  final String email;
  
  Contact({required this.email});
}

// Valid emails
final validEmails = [
  'user@example.com',
  'test.email+tag@example.co.uk',
  'user123@subdomain.example.com'
];

// Invalid emails
final invalidEmails = [
  'invalid.email',
  '@example.com',
  'user@',
  'user @example.com'
];
```

### Date Format Validation
```dart
@Schema()
class Event {
  @IsDate()  // YYYY-MM-DD format
  final String date;
  
  @IsDateTime()  // ISO 8601 format
  final String timestamp;
  
  Event({required this.date, required this.timestamp});
}

// Valid examples
final validEvent = {
  'date': '2023-12-25',
  'timestamp': '2023-12-25T10:30:00Z'
};

// Invalid examples
final invalidEvent = {
  'date': '12/25/2023',  // Wrong format
  'timestamp': '2023-12-25 10:30:00'  // Not ISO 8601
};
```

### Pattern Matching
```dart
@Schema()
class Account {
  @Pattern(r'^[A-Z][0-9]{6}$')  // e.g., A123456
  final String accountId;
  
  @Pattern(r'^\+?[1-9]\d{1,14}$')  // E.164 phone format
  final String? phoneNumber;
  
  Account({required this.accountId, this.phoneNumber});
}
```

## List Validation Features

### Unique Items
```dart
@Schema()
class TaggedContent {
  @UniqueItems()
  @MinItems(1)
  @MaxItems(10)
  final List<String> tags;
  
  TaggedContent({required this.tags});
}

// Valid
final valid = TaggedContent(tags: ['dart', 'flutter', 'mobile']);

// Invalid - duplicate tags
final invalid = TaggedContent(tags: ['dart', 'flutter', 'dart']);
```

### Length Constraints
```dart
@Schema()
class Team {
  @Length(5)  // Exactly 5 members
  final List<String> members;
  
  @MinItems(2)
  @MaxItems(4)
  final List<String> substitutes;
  
  Team({required this.members, required this.substitutes});
}
```

## Boolean and Number Validation

### Boolean Fields
```dart
@Schema()
class Settings {
  @DefaultValue(false)
  final bool darkMode;
  
  @DefaultValue(true)
  final bool notifications;
  
  final bool? betaFeatures;  // Optional boolean
  
  Settings({
    this.darkMode = false,
    this.notifications = true,
    this.betaFeatures,
  });
}
```

### Number Constraints
```dart
@Schema()
class Product {
  @Min(0)
  @Max(1000000)
  final double price;
  
  @MultipleOf(5)
  final int quantity;
  
  @IsPositive()
  final double? discount;
  
  Product({
    required this.price,
    required this.quantity,
    this.discount,
  });
}
```

## Working with Nested Models

### Complex Nested Structure
```dart
@Schema()
class Address {
  @IsNotEmpty()
  final String street;
  
  @IsNotEmpty()
  final String city;
  
  @Pattern(r'^\d{5}(-\d{4})?$')  // US ZIP code
  final String zipCode;
  
  Address({
    required this.street,
    required this.city,
    required this.zipCode,
  });
  
  factory Address.fromSchema(AddressSchema schema) {
    return Address(
      street: schema.street,
      city: schema.city,
      zipCode: schema.zipCode,
    );
  }
}

@Schema()
class Customer {
  final String name;
  final Address billingAddress;
  final Address? shippingAddress;
  
  @MinItems(1)
  final List<Address>? previousAddresses;
  
  Customer({
    required this.name,
    required this.billingAddress,
    this.shippingAddress,
    this.previousAddresses,
  });
  
  factory Customer.fromSchema(CustomerSchema schema) {
    return Customer(
      name: schema.name,
      billingAddress: Address.fromSchema(schema.billingAddress),
      shippingAddress: schema.shippingAddress != null
          ? Address.fromSchema(schema.shippingAddress!)
          : null,
      previousAddresses: schema.previousAddresses
          ?.map((addr) => Address.fromSchema(addr))
          .toList(),
    );
  }
}
```

Using nested schemas:
```dart
final customerData = {
  'name': 'John Smith',
  'billingAddress': {
    'street': '123 Main St',
    'city': 'New York',
    'zipCode': '10001'
  },
  'shippingAddress': {
    'street': '456 Oak Ave',
    'city': 'Boston',
    'zipCode': '02101'
  }
};

// Create schema instance
final customerSchema = CustomerSchema(customerData);

// Access nested properties directly
if (customerSchema.isValid) {
  // Access nested schemas
  print('Billing City: ${customerSchema.billingAddress.city}');
  
  // Access optional nested schema
  if (customerSchema.shippingAddress != null) {
    print('Shipping City: ${customerSchema.shippingAddress!.city}');
  }
  
  // Create model when needed
  final customer = Customer.fromSchema(customerSchema);
}
```

## Schema Registry Usage

The `SchemaRegistry` allows dynamic schema creation:

```dart
// Register schemas
SchemaRegistry.register<UserSchema>((data) => UserSchema(data));
SchemaRegistry.register<ProfileSchema>((data) => ProfileSchema(data));

// Use registry to create schemas dynamically
final userData = {'name': 'John', 'email': 'john@example.com'};

// Create a UserSchema instance using the registered factory
final schema = SchemaRegistry.createSchema<UserSchema>(userData);

if (schema != null && schema.isValid) {
  print('Name: ${schema.name}');
  print('Email: ${schema.email}');
}
```

## Key BaseSchema Methods

Every generated schema class provides these methods:

```dart
// Check if data is valid
bool get isValid;

// Get validation errors (null if valid)
SchemaError? getErrors();

// Access validated data as a map
Map<String, dynamic> toMap();

// Convert to JSON string
String toJson();

// Access typed properties through generated getters
// e.g., schema.name, schema.email, etc.
```

## Conclusion

Ack 0.2.0 introduces several powerful new features:

1. **Code Generation**: Automatically generate schema classes from annotated models
2. **Automatic Inference**: Required/optional fields determined from constructors, nullable types from field declarations
3. **Enhanced String Validation**: Email, date, and pattern matching
4. **List Validation**: Unique items, length constraints
5. **Nested Model Support**: Seamless validation of complex object graphs
6. **Additional Properties**: Capture and validate dynamic fields
7. **Schema Registry**: Dynamic schema creation and management
8. **Direct Property Access**: Type-safe access to validated data through generated getters

These features make Ack a powerful and flexible validation library that works seamlessly with Dart's type system while maintaining simplicity and ease of use.