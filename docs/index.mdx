---
title: Overview
---
Ack is a schema validation library for Dart and Flutter that helps you validate data with a simple, fluent API. Ack is short for "acknowledgment".

## Why Use Ack?

- **Simplify Validation**: Easily handle complex data validation logic.
- **Ensure Data Integrity**: Guarantee data consistency from external sources (APIs, user input).
- **Single Source of Truth**: Define data structures and rules in one place.
- **Reduce Boilerplate**: Minimize repetitive code for validation and JSON conversion.

## What Ack Does

- Ensures data conforms to your defined schemas
- Facilitates seamless conversion between JSON and Dart models
- Generates JSON Schema specifications from your schemas
- Delivers detailed and easy-to-understand validation error messages

## Quick Start

Add Ack to your project:

```bash
dart pub add ack
```

### Basic Usage

```dart
import 'package:ack/ack.dart';

// Define the structure and rules for a user object.
final userSchema = Ack.object({
  'name': Ack.string().minLength(2).maxLength(50), // Name must be a string between 2 and 50 chars.
  'age': Ack.integer().min(0).max(120),            // Age must be an integer between 0 and 120.
  'email': Ack.string().email().nullable(),        // Email must be a valid format, but can be null.
}); // All fields are required by default

// Data to validate.
final dataToValidate = {
  'name': 'John',
  'age': 30,
  'email': 'john@example.com'
};

// Perform the validation against the schema.
final result = userSchema.validate(dataToValidate);

// Check the validation outcome.
if (result.isOk) {
  // Validation passed, safely access the validated data.
  final validData = result.getOrThrow();
  print('Valid data: $validData');
} else {
  // Validation failed, access the detailed error.
  final error = result.getError();
  print('Validation Error: $error'); // Use error.toString() for full details.
}
```

## Core Features

Ack provides a comprehensive set of features for data validation and transformation:

- **[Schema Types](/core-concepts/schemas)**: Define data structures with strings, numbers, booleans, lists, objects, and more
- **[Validation Rules](/core-concepts/validation)**: Apply constraints like length, range, pattern matching, and custom validators
- **[Schema Validation](/core-concepts/typesafe-schemas)**: Comprehensive schema validation with fluent API
- **[Error Handling](/core-concepts/error-handling)**: Get detailed, structured error messages for validation failures
- **[JSON Serialization](/core-concepts/json-serialization)**: Convert between JSON and typed models

### Advanced Schema Validation

Create complex validation schemas with the fluent API:

```dart
import 'package:ack/ack.dart';

// Complex nested validation
final orderSchema = Ack.object({
  'id': Ack.string().uuid(),
  'customer': Ack.object({
    'name': Ack.string().minLength(2),
    'email': Ack.string().email(),
  }),
  'items': Ack.list(Ack.object({
    'product': Ack.string(),
    'quantity': Ack.integer().positive(),
    'price': Ack.double().positive(),
  })).minLength(1),
  'total': Ack.double().positive(),
}).refine(
  (order) {
    // Custom validation: total should match sum of items
    final items = order['items'] as List;
    final calculatedTotal = items.fold<double>(0, (sum, item) {
      final itemMap = item as Map<String, Object?>;
      final quantity = itemMap['quantity'] as int;
      final price = itemMap['price'] as double;
      return sum + (quantity * price);
    });
    final total = order['total'] as double;
    return (calculatedTotal - total).abs() < 0.01;
  },
  message: 'Total must match sum of item prices',
);

// Validate complex data
final result = orderSchema.validate(orderData);
if (result.isOk) {
  final validOrder = result.getOrThrow();
  print('Valid order: ${validOrder['id']}');
} else {
  print('Validation failed: ${result.getError()}');
}
```

### Schema Features

**1. Union Types and Discriminated Unions**

```dart
// Union type - value can be string or number
final stringOrNumber = Ack.anyOf([
  Ack.string(),
  Ack.integer(),
]);

// Discriminated union for polymorphic data
final shapeSchema = Ack.discriminated(
  discriminatorKey: 'type',
  schemas: {
    'circle': Ack.object({
      'type': Ack.literal('circle'),
      'radius': Ack.double().positive(),
    }),
    'rectangle': Ack.object({
      'type': Ack.literal('rectangle'),
      'width': Ack.double().positive(),
      'height': Ack.double().positive(),
    }),
  },
);
```

**2. Flexible Data Handling**

```dart
// Accept any data for gradual migration
final flexibleSchema = Ack.object({
  'id': Ack.string(),
  'data': Ack.any(), // Accept anything
});

// Transform data after validation
final processedSchema = Ack.object({
  'name': Ack.string(),
  'birthYear': Ack.integer(),
}).transform((data) {
  final age = DateTime.now().year - (data!['birthYear'] as int);
  return {...data, 'age': age};
});
```

**3. JSON Schema Generation**

```dart
// Generate JSON Schema for documentation
final jsonSchema = orderSchema.toJsonSchema();
print(jsonEncode(jsonSchema)); // Use in API docs, OpenAPI specs, etc.
```

### Error Handling

```dart
if (result.isFail) {
  // Get formatted error message (or the full error object)
  final error = result.getError();
  print('${error.name}: $error'); // Full error details
}
```