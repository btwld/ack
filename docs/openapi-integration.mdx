---
title: OpenAPI Integration and LLM Function Calling
---

This guide shows how to use Ack to generate OpenAPI schemas for API documentation and LLM function calling.

## OpenAPI Schema Generation

Ack can automatically generate OpenAPI-compatible schemas from your validation schemas:

```dart
import 'package:ack/ack.dart';

void main() {
  // Define a schema for an API endpoint
  final createUserSchema = Ack.object(
    {
      'name': Ack.string.minLength(2).maxLength(50),
      'email': Ack.string.isEmail(),
      'role': Ack.string.nullable(),
      'preferences': Ack.object(
        {
          'darkMode': Ack.boolean.nullable(),
          'notifications': Ack.boolean.nullable(),
        },
      ).nullable(),
    },
    required: ['name', 'email'],
  );

  // Convert to OpenAPI schema
  final converter = OpenApiSchemaConverter(schema: createUserSchema);
  final openApiSchema = converter.toSchema();

  print('OpenAPI Schema:');
  print(openApiSchema);
}
```

The generated schema will be compatible with OpenAPI 3.0 specifications and can be used in API documentation tools like Swagger.

## Default Values

You can apply default values after validation:

```dart
// Apply default values after validation if needed
final result = createUserSchema.validate({
  'name': 'John Doe',
  'email': 'john@example.com',
});

if (result.isOk) {
  final data = result.getOrThrow();
  // Apply defaults to optional fields
  final role = data['role'] ?? 'user';
  final preferences = data['preferences'] ?? {
    'darkMode': false,
    'notifications': true,
  };

  print('User with defaults: name=${data['name']}, role=$role');
}
```

## LLM Function Calling

Ack is particularly useful for validating inputs and outputs when working with Large Language Models (LLMs):

```dart
// For LLM integration
final promptTemplate = '''
You are a helpful assistant. Please create a user with the following schema:

${converter.toResponsePrompt()}

Please provide valid user data.
''';

print('\nLLM Prompt Template:');
print(promptTemplate);

// Simulated LLM response
final llmResponse = '''
I'll create a user for you:

<response>
{
  "name": "Alice Smith",
  "email": "alice@example.com",
  "preferences": {
    "darkMode": true,
    "notifications": false
  }
}
</response>
''';

// Parse and validate the LLM response
try {
  final parsedResponse = converter.parseResponse(llmResponse);
  print('\nParsed LLM Response:');
  print(parsedResponse);
} catch (e) {
  print('\nError parsing LLM response: $e');
}
```

## Function Calling with OpenAI

When using OpenAI's function calling feature, you can generate compatible schemas:

```dart
// Define your schema
final weatherQuerySchema = Ack.object({
  'location': Ack.string.minLength(2).maxLength(100),
  'unit': Ack.string.isEnum(['celsius', 'fahrenheit']).nullable(),
  'date': Ack.string.matches(r'^\d{4}-\d{2}-\d{2}$') // ISO date format (YYYY-MM-DD)
    .nullable(),
});

// Convert to OpenAI function schema
final converter = OpenApiSchemaConverter(schema: weatherQuerySchema);
final functionSchema = converter.toOpenAIFunctionSchema(
  name: 'get_weather',
  description: 'Get the weather forecast for a location',
);

// Use with OpenAI API
final openAIRequest = {
  'model': 'gpt-4',
  'messages': [
    {'role': 'user', 'content': 'What\'s the weather like in New York?'}
  ],
  'functions': [functionSchema],
  'function_call': 'auto',
};

// When you receive a function call from OpenAI, validate it
final functionCallArgs = '{"location": "New York", "unit": "celsius"}';
final validationResult = weatherQuerySchema.validate(jsonDecode(functionCallArgs));

if (validationResult.isOk) {
  // Process the validated function call
  final args = validationResult.getOrThrow();
  final weatherData = getWeatherData(
    location: args['location'],
    unit: args['unit'] ?? 'celsius',
    date: args['date'],
  );

  // Return response to OpenAI
}
```

## Anthropic Claude Function Calling

For Anthropic's Claude, you can generate compatible schemas:

```dart
// Convert to Claude tool schema
final toolSchema = converter.toClaudeToolSchema(
  name: 'get_weather',
  description: 'Get the weather forecast for a location',
);

// Use with Claude API
final claudeRequest = {
  'model': 'claude-3-opus-20240229',
  'messages': [
    {'role': 'user', 'content': 'What\'s the weather like in New York?'}
  ],
  'tools': [toolSchema],
};

// When you receive a tool call from Claude, validate it
final toolCallArgs = '{"location": "New York", "unit": "celsius"}';
final validationResult = weatherQuerySchema.validate(jsonDecode(toolCallArgs));

if (validationResult.isOk) {
  // Process the validated tool call
  final args = validationResult.getOrThrow();
  // ...
}
```

## Schema Documentation

You can also generate human-readable documentation for your schemas:

```dart
// Generate documentation for a schema
final documentation = converter.toDocumentation();
print(documentation);

// Example output:
// # User Schema
//
// ## Required Fields
// - name (string): Must be between 2 and 50 characters
// - email (string): Must be a valid email address
//
// ## Optional Fields
// - role (string or null)
// - preferences (object or null):
//   - darkMode (boolean or null)
//   - notifications (boolean or null)
```

## Best Practices

1. **Define schemas once** and use them for both validation and documentation
2. **Include descriptions** for better documentation
3. **Use enums** for fields with a fixed set of values
4. **Validate LLM responses** before using them
5. **Apply default values** for optional fields

By using Ack for OpenAPI integration and LLM function calling, you can ensure that your API is well-documented and that interactions with LLMs are validated and type-safe.
