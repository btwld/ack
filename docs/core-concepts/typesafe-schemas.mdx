# Schema Validation

## Overview

Ack provides a comprehensive schema validation system that helps you validate data with a simple, fluent API. The schema system is built around the `AckSchema` base class and provides type-safe validation for various data types.

## Core Schema Types

Ack includes built-in schemas for common data types:

- **StringSchema** - Validates strings with constraints like length, format, patterns
- **IntegerSchema** - Validates integers with numeric constraints
- **DoubleSchema** - Validates floating-point numbers
- **BooleanSchema** - Validates boolean values
- **ObjectSchema** - Validates objects/maps with nested property validation
- **ListSchema** - Validates arrays with item validation
- **EnumSchema** - Validates enum values
- **AnyOfSchema** - Validates against multiple possible schemas (union types)
- **AnySchema** - Accepts any value without validation (for maximum flexibility)

## Basic Usage

### Creating Schemas

Use the `Ack` factory class to create schemas:

```dart
import 'package:ack/ack.dart';

// String validation
final nameSchema = Ack.string().minLength(2).maxLength(50);

// Numeric validation
final ageSchema = Ack.integer().min(0).max(120);

// Email validation
final emailSchema = Ack.string().email();

// Object validation
final userSchema = Ack.object({
  'name': nameSchema,
  'age': ageSchema,
  'email': emailSchema,
});
```

### Validating Data

Use the `validate()` method to check data against a schema:

```dart
// Sample data to validate
final userData = {
  'name': 'John Doe',
  'age': 30,
  'email': 'john@example.com',
};

// Validate the data
final result = userSchema.validate(userData);

if (result.isOk) {
  // Validation passed - get the validated data
  final validData = result.getOrThrow();
  print('Valid user: ${validData['name']}');
} else {
  // Validation failed - handle the error
  final error = result.getError();
  print('Validation failed: $error');
}
```

## Advanced Features

### 1. Optional vs Nullable Fields

Understanding the difference between `.optional()` and `.nullable()` is crucial:

**`.nullable()`** - The field must be present but can have a `null` value:
```dart
final userSchema = Ack.object({
  'name': Ack.string(),
  'middleName': Ack.string().nullable(), // Must be present, can be null
});

// ✅ Valid - middleName is present with null value
final validData1 = {'name': 'John', 'middleName': null};

// ✅ Valid - middleName is present with string value
final validData2 = {'name': 'John', 'middleName': 'Robert'};

// ❌ Invalid - middleName is missing entirely
final invalidData = {'name': 'John'}; // Validation fails
```

**`.optional()`** - The field can be completely omitted from the object:
```dart
final userSchema = Ack.object({
  'name': Ack.string(),
  'age': Ack.integer().min(0).optional(), // Can be missing entirely
});

// ✅ Valid - age field is omitted
final validData1 = {'name': 'John'};

// ✅ Valid - age field is present with value
final validData2 = {'name': 'John', 'age': 30};

// ❌ Invalid - age field cannot be null (use .optional().nullable() for that)
final invalidData = {'name': 'John', 'age': null}; // Validation fails
```

**Combining both** - Field can be omitted OR present with null value:
```dart
final userSchema = Ack.object({
  'name': Ack.string(),
  'bio': Ack.string().optional().nullable(), // Can be missing OR null
});

// ✅ All of these are valid:
final valid1 = {'name': 'John'}; // bio omitted
final valid2 = {'name': 'John', 'bio': null}; // bio is null
final valid3 = {'name': 'John', 'bio': 'Software developer'}; // bio has value
```

**Common patterns:**
```dart
// API response where field might not exist
final apiSchema = Ack.object({
  'id': Ack.string(),
  'metadata': Ack.any().optional(), // Field might not be in response
});

// Database record where field can be NULL
final dbSchema = Ack.object({
  'id': Ack.string(),
  'deletedAt': Ack.string().datetime().nullable(), // Present but can be NULL
});

// Form data where field is optional and can be empty
final formSchema = Ack.object({
  'name': Ack.string(),
  'comments': Ack.string().optional().nullable(), // Can be missing or empty
});
```

### 2. Custom Validation with Refinements

Add custom validation logic using refinements:

```dart
// Password confirmation validation
final passwordSchema = Ack.object({
  'password': Ack.string().minLength(8),
  'confirmPassword': Ack.string().minLength(8),
}).refine(
  (data) => data['password'] == data['confirmPassword'],
  message: 'Passwords must match',
);

// Age validation with custom logic
final adultUserSchema = Ack.object({
  'name': Ack.string(),
  'birthYear': Ack.integer().min(1900).max(2024),
}).refine(
  (data) {
    final birthYear = data['birthYear'] as int;
    final currentYear = DateTime.now().year;
    final age = currentYear - birthYear;
    return age >= 18;
  },
  message: 'User must be at least 18 years old',
);

// Multiple refinements can be chained
final strongPasswordSchema = Ack.string()
    .minLength(8)
    .refine(
      (password) => password.contains(RegExp(r'[A-Z]')),
      message: 'Password must contain at least one uppercase letter',
    )
    .refine(
      (password) => password.contains(RegExp(r'[0-9]')),
      message: 'Password must contain at least one number',
    )
    .refine(
      (password) => password.contains(RegExp(r'[!@#$%^&*(),.?":{}|<>]')),
      message: 'Password must contain at least one special character',
    );

// Business logic validation
final orderSchema = Ack.object({
  'items': Ack.list(Ack.object({
    'price': Ack.double().positive(),
    'quantity': Ack.integer().positive(),
  })),
  'discount': Ack.double().min(0).max(1),
  'total': Ack.double().positive(),
}).refine(
  (order) {
    final items = order['items'] as List;
    final discount = order['discount'] as double;
    final total = order['total'] as double;

    final subtotal = items.fold<double>(0, (sum, item) {
      final itemMap = item as Map<String, Object?>;
      final price = itemMap['price'] as double;
      final quantity = itemMap['quantity'] as int;
      return sum + (price * quantity);
    });

    final expectedTotal = subtotal * (1 - discount);
    return (expectedTotal - total).abs() < 0.01; // Allow for rounding
  },
  message: 'Total must match calculated amount after discount',
);
```

### 3. Transformations

Transform validated data into different formats:

```dart
// Transform string to uppercase
final upperCaseNameSchema = Ack.string()
    .minLength(2)
    .transform((name) => name?.toUpperCase() ?? '');

// Transform object to add computed fields
final userWithAgeSchema = Ack.object({
  'name': Ack.string(),
  'birthYear': Ack.integer(),
}).transform((data) {
  final birthYear = data!['birthYear'] as int;
  final age = DateTime.now().year - birthYear;
  return {
    ...data,
    'age': age,
  };
});

// Type transformation - string to DateTime
final dateSchema = Ack.string()
    .matches(r'^\d{4}-\d{2}-\d{2}$')
    .transform<DateTime>((dateStr) {
      return DateTime.parse(dateStr!);
    });

// Data normalization
final phoneSchema = Ack.string()
    .matches(r'^[\d\s\-\(\)\+]+$')
    .transform((phone) {
      // Remove all non-digit characters except +
      return phone!.replaceAll(RegExp(r'[^\d\+]'), '');
    });

// Complex object transformation
final apiResponseSchema = Ack.object({
  'user_id': Ack.integer(),
  'first_name': Ack.string(),
  'last_name': Ack.string(),
  'email_address': Ack.string().email(),
  'created_at': Ack.string().datetime(),
}).transform<Map<String, Object?>>((apiData) {
  // Transform API response to internal format
  return {
    'id': apiData!['user_id'],
    'fullName': '${apiData['first_name']} ${apiData['last_name']}',
    'email': apiData['email_address'],
    'createdAt': DateTime.parse(apiData['created_at'] as String),
    'isActive': true, // Default value
  };
});

// Chaining transformations with validation
final processedUserSchema = Ack.object({
  'name': Ack.string(),
  'email': Ack.string().email(),
  'age': Ack.integer().min(0),
}).transform<Map<String, Object?>>((user) {
  return {
    ...user!,
    'slug': (user['name'] as String).toLowerCase().replaceAll(' ', '-'),
    'category': (user['age'] as int) >= 18 ? 'adult' : 'minor',
  };
}).refine(
  (processed) => (processed['slug'] as String).isNotEmpty,
  message: 'Generated slug cannot be empty',
);
```
```

### 4. JSON Schema Generation

Generate JSON Schema for documentation or API specifications:

```dart
// Generate JSON Schema from any schema
final userSchema = Ack.object({
  'name': Ack.string().minLength(2).maxLength(50),
  'email': Ack.string().email(),
  'age': Ack.integer().min(18).max(120),
});

final jsonSchema = userSchema.toJsonSchema();

// Use in API documentation, OpenAPI specs, etc.
import 'dart:convert';
final jsonString = jsonEncode(jsonSchema);

// Example output:
// {
//   "type": "object",
//   "properties": {
//     "name": {
//       "type": "string",
//       "minLength": 2,
//       "maxLength": 50
//     },
//     "email": {
//       "type": "string",
//       "format": "email"
//     },
//     "age": {
//       "type": "integer",
//       "minimum": 18,
//       "maximum": 120
//     }
//   },
//   "required": ["name", "email", "age"]
// }
```

## Complex Validation Scenarios

### Nested Object Validation

```dart
// Address schema
final addressSchema = Ack.object({
  'street': Ack.string().minLength(1),
  'city': Ack.string().minLength(1),
  'zipCode': Ack.string().matches(r'^\d{5}(-\d{4})?$'),
});

// User with nested address
final userWithAddressSchema = Ack.object({
  'name': Ack.string().minLength(2),
  'email': Ack.string().email(),
  'address': addressSchema, // Nested validation
});

### List Validation

```dart
// Validate arrays of items
final numbersSchema = Ack.list(Ack.integer().positive()).minLength(1);

// Validate array of objects
final usersSchema = Ack.list(userSchema).maxLength(10);

// Validate with custom refinements
final uniqueEmailsSchema = Ack.list(userSchema).refine(
  (users) {
    final emails = users.map((u) => u['email']).toSet();
    return emails.length == users.length;
  },
  message: 'All users must have unique email addresses',
);
```

### Union Types (AnyOf)

```dart
// Value can be either a string or a number
final stringOrNumberSchema = Ack.anyOf([
  Ack.string(),
  Ack.integer(),
]);

// More complex union types
final contactSchema = Ack.anyOf([
  Ack.object({
    'type': Ack.literal('email'),
    'value': Ack.string().email(),
  }),
  Ack.object({
    'type': Ack.literal('phone'),
    'value': Ack.string().matches(r'^\+?[\d\s\-\(\)]+$'),
  }),
]);
```

### Discriminated Unions

```dart
// Polymorphic validation based on a discriminator field
final shapeSchema = Ack.discriminated(
  discriminatorKey: 'type',
  schemas: {
    'circle': Ack.object({
      'type': Ack.literal('circle'),
      'radius': Ack.double().positive(),
    }),
    'rectangle': Ack.object({
      'type': Ack.literal('rectangle'),
      'width': Ack.double().positive(),
      'height': Ack.double().positive(),
    }),
  },
);

// Usage example
final circleData = {
  'type': 'circle',
  'radius': 5.0,
};

final rectangleData = {
  'type': 'rectangle',
  'width': 10.0,
  'height': 20.0,
};

final circleResult = shapeSchema.validate(circleData);
final rectangleResult = shapeSchema.validate(rectangleData);

if (circleResult.isOk) {
  final shape = circleResult.getOrThrow();
  print('Circle with radius: ${shape['radius']}');
}
```

## Error Handling

Ack provides detailed error information when validation fails:

```dart
final result = userSchema.validate(invalidData);

if (result.isFail) {
  final error = result.getError();

  // Different error types provide different information
  if (error is SchemaConstraintsError) {
    print('Constraint violations:');
    for (final constraint in error.constraints) {
      print('- ${constraint.message}');
    }
  } else if (error is SchemaNestedError) {
    print('Nested validation errors:');
    for (final nestedError in error.errors) {
      print('- ${nestedError.message}');
    }
  }
}
```

## Best Practices

### 1. Schema Reuse

Define reusable schemas for common patterns:

```dart
// Common schemas
final emailSchema = Ack.string().email();
final uuidSchema = Ack.string().uuid();
final timestampSchema = Ack.string().datetime();

// Reuse in multiple schemas
final userSchema = Ack.object({
  'id': uuidSchema,
  'email': emailSchema,
  'createdAt': timestampSchema,
});

final postSchema = Ack.object({
  'id': uuidSchema,
  'authorId': uuidSchema,
  'createdAt': timestampSchema,
});
```

### 2. Schema Composition and Extension

Build complex schemas by composing and extending simpler ones:

```dart
// Base schemas for reuse
final addressSchema = Ack.object({
  'street': Ack.string(),
  'city': Ack.string(),
  'country': Ack.string(),
  'postalCode': Ack.string().matches(r'^\d{5}(-\d{4})?$'),
});

final contactSchema = Ack.object({
  'email': Ack.string().email(),
  'phone': Ack.string().optional(),
});

// Compose schemas into more complex ones
final customerSchema = Ack.object({
  'id': Ack.string().uuid(),
  'name': Ack.string(),
  'contact': contactSchema,
  'billingAddress': addressSchema,
  'shippingAddress': addressSchema.optional(),
});

// Extend existing schemas
final premiumCustomerSchema = customerSchema.extend({
  'membershipLevel': Ack.enumString(['gold', 'platinum', 'diamond']),
  'loyaltyPoints': Ack.integer().min(0),
  'personalManager': Ack.object({
    'name': Ack.string(),
    'email': Ack.string().email(),
  }).optional(),
});

// Make all fields optional for partial updates
final customerUpdateSchema = customerSchema.partial();

// Pick specific fields for different use cases
final customerSummarySchema = customerSchema.pick(['id', 'name', 'contact']);

// Omit sensitive fields for public APIs
final publicCustomerSchema = customerSchema.omit(['billingAddress']);
```

### 3. Gradual Validation

Use `AnySchema` for gradual migration or flexible APIs:

```dart
// Accept any data initially, add validation incrementally
final flexibleSchema = Ack.object({
  'id': Ack.string(), // Validated
  'data': Ack.any(),  // Accept anything for now
});

// Later, add more specific validation
final stricterSchema = Ack.object({
  'id': Ack.string().uuid(),
  'data': Ack.object({
    'name': Ack.string().minLength(1),
    'value': Ack.integer(),
  }),
});
```

### 3. Performance Considerations

- Reuse schema instances when possible (they're immutable)
- Use `safeParse()` instead of `parse()` when you expect validation failures
- Consider using `transform()` for expensive computations only after validation passes

```dart
// ✅ Good: Reuse schema instances
final userSchema = Ack.object({...});

// Use the same instance multiple times
final result1 = userSchema.validate(data1);
final result2 = userSchema.validate(data2);

// ✅ Good: Use safeParse for expected failures
final result = userSchema.safeParse(untrustedData);
if (result.isOk) {
  // Handle success
} else {
  // Handle expected failure gracefully
}
```