# Schema Validation

## Overview

Ack provides a comprehensive schema validation system that helps you validate data with a simple, fluent API. The schema system is built around the `AckSchema` base class and provides type-safe validation for various data types.

## Core Schema Types

Ack includes built-in schemas for common data types:

- **StringSchema** - Validates strings with constraints like length, format, patterns
- **IntegerSchema** - Validates integers with numeric constraints
- **DoubleSchema** - Validates floating-point numbers
- **BooleanSchema** - Validates boolean values
- **ObjectSchema** - Validates objects/maps with nested property validation
- **ListSchema** - Validates arrays with item validation
- **EnumSchema** - Validates enum values
- **AnyOfSchema** - Validates against multiple possible schemas (union types)
- **AnySchema** - Accepts any value without validation (for maximum flexibility)

## Basic Usage

### Creating Schemas

Use the `Ack` factory class to create schemas:

```dart
import 'package:ack/ack.dart';

// String validation
final nameSchema = Ack.string().minLength(2).maxLength(50);

// Numeric validation
final ageSchema = Ack.integer().min(0).max(120);

// Email validation
final emailSchema = Ack.string().email();

// Object validation
final userSchema = Ack.object({
  'name': nameSchema,
  'age': ageSchema,
  'email': emailSchema,
});
```

### Validating Data

Use the `validate()` method to check data against a schema:

```dart
// Sample data to validate
final userData = {
  'name': 'John Doe',
  'age': 30,
  'email': 'john@example.com',
};

// Validate the data
final result = userSchema.validate(userData);

if (result.isOk) {
  // Validation passed - get the validated data
  final validData = result.getOrThrow();
  print('Valid user: ${validData['name']}');
} else {
  // Validation failed - handle the error
  final error = result.getError();
  print('Validation failed: $error');
}
```

## Advanced Features

### 1. Nullable and Optional Fields

```dart
// Nullable field (can be null)
final optionalAgeSchema = Ack.integer().min(0).nullable();

// Optional field (can be omitted from object)
final userWithOptionalAge = Ack.object({
  'name': Ack.string().minLength(2),
  'email': Ack.string().email(),
  'age': Ack.integer().min(0).optional(), // Field can be missing
});
```

### 2. Custom Validation with Refinements

Add custom validation logic using refinements:

```dart
// Password confirmation validation
final passwordSchema = Ack.object({
  'password': Ack.string().minLength(8),
  'confirmPassword': Ack.string().minLength(8),
}).refine(
  (data) => data['password'] == data['confirmPassword'],
  message: 'Passwords must match',
);

// Age validation with custom logic
final adultUserSchema = Ack.object({
  'name': Ack.string(),
  'birthYear': Ack.integer().min(1900).max(2024),
}).refine(
  (data) {
    final birthYear = data['birthYear'] as int;
    final currentYear = DateTime.now().year;
    final age = currentYear - birthYear;
    return age >= 18;
  },
  message: 'User must be at least 18 years old',
);
```

### 3. Transformations

Transform validated data into different formats:

```dart
// Transform string to uppercase
final upperCaseNameSchema = Ack.string()
    .minLength(2)
    .transform((name) => name?.toUpperCase() ?? '');

// Transform object to add computed fields
final userWithAgeSchema = Ack.object({
  'name': Ack.string(),
  'birthYear': Ack.integer(),
}).transform((data) {
  final birthYear = data!['birthYear'] as int;
  final age = DateTime.now().year - birthYear;
  return {
    ...data,
    'age': age,
  };
});
```
```

### 4. JSON Schema Generation

Generate JSON Schema for documentation or API specifications:

```dart
// Generate JSON Schema from any schema
final userSchema = Ack.object({
  'name': Ack.string().minLength(2).maxLength(50),
  'email': Ack.string().email(),
  'age': Ack.integer().min(18).max(120),
});

final jsonSchema = userSchema.toJsonSchema();

// Use in API documentation, OpenAPI specs, etc.
import 'dart:convert';
final jsonString = jsonEncode(jsonSchema);

// Example output:
// {
//   "type": "object",
//   "properties": {
//     "name": {
//       "type": "string",
//       "minLength": 2,
//       "maxLength": 50
//     },
//     "email": {
//       "type": "string",
//       "format": "email"
//     },
//     "age": {
//       "type": "integer",
//       "minimum": 18,
//       "maximum": 120
//     }
//   },
//   "required": ["name", "email", "age"]
// }
```

## Complex Validation Scenarios

### Nested Object Validation

```dart
// Address schema
final addressSchema = Ack.object({
  'street': Ack.string().minLength(1),
  'city': Ack.string().minLength(1),
  'zipCode': Ack.string().matches(r'^\d{5}(-\d{4})?$'),
});

// User with nested address
final userWithAddressSchema = Ack.object({
  'name': Ack.string().minLength(2),
  'email': Ack.string().email(),
  'address': addressSchema, // Nested validation
});

### List Validation

```dart
// Validate arrays of items
final numbersSchema = Ack.list(Ack.integer().positive()).minLength(1);

// Validate array of objects
final usersSchema = Ack.list(userSchema).maxLength(10);

// Validate with custom refinements
final uniqueEmailsSchema = Ack.list(userSchema).refine(
  (users) {
    final emails = users.map((u) => u['email']).toSet();
    return emails.length == users.length;
  },
  message: 'All users must have unique email addresses',
);
```

### Union Types (AnyOf)

```dart
// Value can be either a string or a number
final stringOrNumberSchema = Ack.anyOf([
  Ack.string(),
  Ack.integer(),
]);

// More complex union types
final contactSchema = Ack.anyOf([
  Ack.object({
    'type': Ack.literal('email'),
    'value': Ack.string().email(),
  }),
  Ack.object({
    'type': Ack.literal('phone'),
    'value': Ack.string().matches(r'^\+?[\d\s\-\(\)]+$'),
  }),
]);
```

### Discriminated Unions

```dart
// Polymorphic validation based on a discriminator field
final shapeSchema = Ack.discriminated(
  discriminatorKey: 'type',
  schemas: {
    'circle': Ack.object({
      'type': Ack.literal('circle'),
      'radius': Ack.double().positive(),
    }),
    'rectangle': Ack.object({
      'type': Ack.literal('rectangle'),
      'width': Ack.double().positive(),
      'height': Ack.double().positive(),
    }),
  },
);
```

## Error Handling

Ack provides detailed error information when validation fails:

```dart
final result = userSchema.validate(invalidData);

if (result.isFail) {
  final error = result.getError();

  // Different error types provide different information
  if (error is SchemaConstraintsError) {
    print('Constraint violations:');
    for (final constraint in error.constraints) {
      print('- ${constraint.message}');
    }
  } else if (error is SchemaNestedError) {
    print('Nested validation errors:');
    for (final nestedError in error.errors) {
      print('- ${nestedError.message}');
    }
  }
}
```

## Best Practices

### 1. Schema Reuse

Define reusable schemas for common patterns:

```dart
// Common schemas
final emailSchema = Ack.string().email();
final uuidSchema = Ack.string().uuid();
final timestampSchema = Ack.string().datetime();

// Reuse in multiple schemas
final userSchema = Ack.object({
  'id': uuidSchema,
  'email': emailSchema,
  'createdAt': timestampSchema,
});

final postSchema = Ack.object({
  'id': uuidSchema,
  'authorId': uuidSchema,
  'createdAt': timestampSchema,
});
```

### 2. Gradual Validation

Use `AnySchema` for gradual migration or flexible APIs:

```dart
// Accept any data initially, add validation incrementally
final flexibleSchema = Ack.object({
  'id': Ack.string(), // Validated
  'data': Ack.any(),  // Accept anything for now
});

// Later, add more specific validation
final stricterSchema = Ack.object({
  'id': Ack.string().uuid(),
  'data': Ack.object({
    'name': Ack.string().minLength(1),
    'value': Ack.integer(),
  }),
});
```

### 3. Performance Considerations

- Reuse schema instances when possible (they're immutable)
- Use `safeParse()` instead of `parse()` when you expect validation failures
- Consider using `transform()` for expensive computations only after validation passes

```dart
// ✅ Good: Reuse schema instances
final userSchema = Ack.object({...});

// Use the same instance multiple times
final result1 = userSchema.validate(data1);
final result2 = userSchema.validate(data2);

// ✅ Good: Use safeParse for expected failures
final result = userSchema.safeParse(untrustedData);
if (result.isOk) {
  // Handle success
} else {
  // Handle expected failure gracefully
}
```