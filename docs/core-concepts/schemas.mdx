---
title: Schema Types in Ack
---


This guide covers all the built-in schema types in Ack and their specific validation options.

## Basic Schema Types

### String Schema

Create string validators with various constraints:

```dart
// Basic string schema
final nameSchema = Ack.string();

// String with length constraints
final usernameSchema = Ack.string()
  .minLength(3)
  .maxLength(20)
  .matches(r'[a-zA-Z0-9_]+'); // Regex: letters, numbers, underscore

// Email validation
final emailSchema = Ack.string().email();

// Enum values (select from options)
final roleSchema = Ack.enumString(['admin', 'user', 'guest']);

// Note: For more constraints (e.g., regex patterns), see the [Validation](./validation.mdx) page.
// For custom constraints, see the [Custom Validation](../guides/custom-validation.mdx) page.
```

### Number Schemas

Create validators for integer and decimal values:

```dart
// Integer validation
final ageSchema = Ack.integer()
  .min(0)
  .max(120);

// Double/decimal validation
final priceSchema = Ack.double()
  .min(0.0) // Must be >= 0.0
  .multipleOf(0.01); // Allow only 2 decimal places

// Note: See the [Validation](./validation.mdx) page for more number constraints.
```

### Boolean Schema

Simple true/false validation:

```dart
final isActiveSchema = Ack.boolean();
```

### Date and Time Validation

Validate date and time values using specialized string constraints:

```dart
// Basic date validation (YYYY-MM-DD)
final birthdateSchema = Ack.string().date();

// Date-time validation (ISO 8601 format)
final appointmentSchema = Ack.string().datetime();

// For date range validation or custom formats, see the [Custom Validation](../guides/custom-validation.mdx) page.
```

## Collection Schemas

### List Schema

Validate arrays and lists containing elements of a specific schema type:

```dart
// List of strings
final tagsSchema = Ack.list(Ack.string());

// List with constraints on the list itself
final itemsSchema = Ack.list(Ack.string())
  .minLength(1)       // Must have at least 1 item
  .maxLength(10)      // Must have at most 10 items
  .unique();         // All items must be unique

// List of complex objects (e.g., a list of users)
final usersListSchema = Ack.list(
  Ack.object({
    'id': Ack.integer().positive(),
    'name': Ack.string()
  })
);
```

### Map Schema (Using Object Schema)

While Ack doesn't have a dedicated `Ack.map` schema, you can validate key-value maps using an `Ack.object` with `additionalProperties`:

```dart
// Map that allows any additional properties
final scoresSchema = Ack.object(
  {}, // No predefined properties expected
  additionalProperties: true // Allow any additional properties
);

// Validate a scores map
final result = scoresSchema.validate({'math': 95, 'history': 88});
print(result.isOk); // true

// Note: To validate the types of additional properties,
// define them explicitly in the properties map instead
final typedScoresSchema = Ack.object({
  'math': Ack.integer().min(0).max(100),
  'history': Ack.integer().min(0).max(100),
});
```

## Object Schema

Validate structured data objects with defined properties and types. This is one of the most common schema types.

```dart
// User object schema
final userSchema = Ack.object({
  // Define properties and their schemas
  'name': Ack.string().minLength(1),
  'age': Ack.integer().min(0).optional(),
  'email': Ack.string().email(),
  // Nested object for address
  'address': Ack.object({
    'street': Ack.string(),
    'city': Ack.string(),
    'zipCode': Ack.string().matches(r'\d{5}'), // Simple 5-digit zip code regex
  }).optional(),
});
```

### Optional Fields

Fields in an `Ack.object` are required by default. Use `.optional()` to make fields optional, or `.nullable()` to allow null values.

```dart
final productSchema = Ack.object({
  'id': Ack.string(),                           // Required
  'name': Ack.string(),                         // Required
  'description': Ack.string().optional(),       // Optional (can be omitted)
  'price': Ack.double().min(0),                 // Required
  'tags': Ack.list(Ack.string()).nullable(),    // Required but can be null
});

// Valid: description is missing, tags is null
final validData = {'id': 'p1', 'name': 'Thing', 'price': 9.99, 'tags': null};
print(productSchema.validate(validData).isOk); // true

// Invalid: name is missing
final invalidData = {'id': 'p2', 'price': 19.99};
print(productSchema.validate(invalidData).isOk); // false
```

### Working with Nested Data

When working with nested objects or lists of objects, Ack handles the validation recursively.

**Accessing Validated Nested Data:**

```dart
final userSchema = Ack.object({
  'name': Ack.string(),
  'address': Ack.object({
    'street': Ack.string(),
    'city': Ack.string(),
    'zipCode': Ack.string(),
  }),
  'orders': Ack.list(Ack.object({
    'id': Ack.string(),
    'total': Ack.double().positive(),
  })),
});

final userData = {
  'name': 'John Doe',
  'address': {
    'street': '123 Main St',
    'city': 'Anytown',
    'zipCode': '12345',
  },
  'orders': [
    {'id': 'order-1', 'total': 99.99},
    {'id': 'order-2', 'total': 149.99},
  ],
};

final result = userSchema.validate(userData);
if (result.isOk) {
  final validatedData = result.getOrThrow();

  // Access nested data with type casting
  final name = validatedData['name'] as String;
  final address = validatedData['address'] as Map<String, Object?>;
  final city = address['city'] as String;

  final orders = validatedData['orders'] as List;
  for (final order in orders) {
    final orderMap = order as Map<String, Object?>;
    final orderId = orderMap['id'] as String;
    final total = orderMap['total'] as double;
    print('Order $orderId: \$${total.toStringAsFixed(2)}');
  }
}
```

### Allowing Additional Properties

By default, `Ack.object` ignores properties in the input data that are not defined in the schema. To capture these, use `additionalProperties`:

```dart
final flexibleSchema = Ack.object(
  {
    'id': Ack.integer(),
  },
  // Allow any other properties
  additionalProperties: true,
);

final data = {'id': 1, 'name': 'Gadget', 'color': 'blue'};
final result = flexibleSchema.validate(data);

print(result.isOk); // true

final validated = flexibleSchema.validate({'id': 1, 'name': 'Gadget'}).getOrThrow();
print(validated); // {id: 1, name: Gadget} - Extra properties are included
```

To *disallow* any extra properties, set `additionalProperties: false`:

```dart
final strictSchema = Ack.object(
  {
    'id': Ack.integer(),
    'name': Ack.string(),
  },
  additionalProperties: false,
);

final dataWithExtra = {'id': 1, 'name': 'Test', 'extra': 'disallowed'};
final result = strictSchema.validate(dataWithExtra);

print(result.isOk); // false
print(result.getError()); // Contains info about disallowed property 'extra'
```

## Advanced Object Schema Operations

Object schemas provide powerful methods for schema composition and manipulation:

### Schema Extension

Add new properties or override existing ones:

```dart
final baseUserSchema = Ack.object({
  'id': Ack.string().uuid(),
  'name': Ack.string(),
  'email': Ack.string().email(),
});

// Extend with additional properties
final adminUserSchema = baseUserSchema.extend({
  'role': Ack.literal('admin'),
  'permissions': Ack.list(Ack.string()),
  'lastLogin': Ack.string().datetime().optional(),
});

// Override existing properties
final publicUserSchema = baseUserSchema.extend({
  'email': Ack.string().email().optional(), // Override to make optional
});
```

### Property Selection

Pick specific properties or omit unwanted ones:

```dart
final fullUserSchema = Ack.object({
  'id': Ack.string().uuid(),
  'name': Ack.string(),
  'email': Ack.string().email(),
  'password': Ack.string().minLength(8),
  'createdAt': Ack.string().datetime(),
  'updatedAt': Ack.string().datetime(),
});

// Pick only specific fields for public API
final publicUserSchema = fullUserSchema.pick(['id', 'name', 'email']);

// Omit sensitive fields
final safeUserSchema = fullUserSchema.omit(['password']);

// Create update schema (omit read-only fields)
final userUpdateSchema = fullUserSchema.omit(['id', 'createdAt']);
```

### Partial Schemas

Make all properties optional for partial updates:

```dart
final userSchema = Ack.object({
  'name': Ack.string(),
  'email': Ack.string().email(),
  'age': Ack.integer().min(0),
});

// All fields become optional
final partialUserSchema = userSchema.partial();

// Now all these are valid:
partialUserSchema.validate({}); // Empty object
partialUserSchema.validate({'name': 'John'}); // Only name
partialUserSchema.validate({'email': 'john@example.com', 'age': 30}); // Subset
```

### Strict vs Passthrough

Control additional property handling:

```dart
final baseSchema = Ack.object({
  'id': Ack.string(),
  'name': Ack.string(),
});

// Strict: reject additional properties
final strictSchema = baseSchema.strict();
strictSchema.validate({'id': '1', 'name': 'Test', 'extra': 'value'}); // Fails

// Passthrough: allow additional properties (default behavior)
final passthroughSchema = baseSchema.passthrough();
passthroughSchema.validate({'id': '1', 'name': 'Test', 'extra': 'value'}); // Succeeds
```

## Making Schemas Nullable

Any schema type can be made nullable by appending `.nullable()`. This means the schema will accept both its defined type *and* the value `null`.

```dart
// Nullable string
final middleNameSchema = Ack.string().nullable();

// Nullable date
final optionalDateSchema = Ack.string().datetime().nullable();

// Nullable object (the entire address object can be null)
final optionalAddressSchema = Ack.object({
  'street': Ack.string(),
  'city': Ack.string(),
}).nullable(); // Note .nullable() is outside Ack.object

// --- Validation Examples ---

// String checks
print(middleNameSchema.validate(null).isOk); // true
print(middleNameSchema.validate('Robert').isOk); // true

// Object checks
print(optionalAddressSchema.validate(null).isOk); // true (null object is allowed)
final validAddress = {'street': '1 Elm St', 'city': 'Gotham'};
print(optionalAddressSchema.validate(validAddress).isOk); // true (valid address object)

// Invalid nested object still fails even if object is nullable
final invalidAddress = {'street': '1 Elm St'}; // Missing required 'city'
print(optionalAddressSchema.validate(invalidAddress).isOk); // false
```