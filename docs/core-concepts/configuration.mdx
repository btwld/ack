---
title: Configuration
---

Ack allows for some configuration settings, although most behavior is controlled directly through the schema definitions when they are created.

## Global Settings (Less Common)

In general, Ack prefers configuration per schema definition rather than global settings. However, if needed, you might manage global aspects like custom format registries or shared validation logic through your own application structure (e.g., dependency injection or service patterns).

*Currently, Ack does not expose a dedicated global configuration object. Configuration is primarily done at the schema level.*

## Schema-Level Configuration

Most "configuration" happens when you define your schemas using the fluent API provided by Ack.

### Required Fields

Use the `required` parameter in [`Ack.object`](./schemas.mdx#object-schema) to specify mandatory fields within an object.

```dart
Ack.object({
  'id': Ack.integer(),
  'name': Ack.string(),
  'email': Ack.string().email().optional() // Email is optional (can be omitted)
}); // id and name are required by default
```

### Additional Properties

Control how extra fields (not defined in the schema) are handled using the `additionalProperties` parameter in [`Ack.object`](./schemas.mdx#object-schema).

```dart
// Allow any extra properties (default behavior)
Ack.object({
  'id': Ack.integer()
}, additionalProperties: true);
// or simply:
Ack.object({
  'id': Ack.integer()
});

// Disallow any extra properties
Ack.object({
  'id': Ack.integer()
}, additionalProperties: false);
```

### Custom Error Messages

Built-in validation rules provide default error messages. For custom error messages, use custom constraints with the `.constrain()` method.
See also: [Custom Error Messages in Error Handling](./error-handling.mdx#custom-error-messages).

```dart
// Built-in constraints use default messages
Ack.string().minLength(5); // Default: "Too short, min 5 characters"
Ack.integer().min(18); // Default: "Must be at least 18"

// For custom messages, use custom constraints (see Custom Validation section below)
```

### Custom Validation Logic

Use `.constrain()` to add reusable validation logic for value-level checks, or `.refine()` for cross-field rules.

```dart
import 'package:ack/ack.dart';

class IsPositiveConstraint extends Constraint<double> with Validator<double> {
  IsPositiveConstraint()
      : super(
          constraintKey: 'is_positive',
          description: 'Number must be positive',
        );

  @override
  bool isValid(double value) => value > 0;

  @override
  String buildMessage(double value) => 'Number must be positive';
}

final priceSchema = Ack.double().constrain(IsPositiveConstraint());

// Cross-field validation (e.g., password confirmation)
final signUpSchema = Ack.object({
  'password': Ack.string().minLength(8),
  'confirmPassword': Ack.string().minLength(8),
}).refine(
  (data) => data['password'] == data['confirmPassword'],
  message: 'Passwords do not match',
);
```
*See the [Custom Validation Guide](../guides/custom-validation.mdx) for additional patterns.*

## Code Generation Configuration

The `ack_generator` package provides automatic schema generation from annotated classes. This feature is production-ready and available at version 1.0.0-beta.1 and later.

To use code generation, annotate your classes with `@AckModel` and use `@AckField` for field-level configuration:

```dart
import 'package:ack_annotations/ack_annotations.dart';

part 'user.g.dart';

@AckModel(
  description: 'User profile with flexible preferences',
  additionalProperties: true,
  additionalPropertiesField: 'preferences'
)
class User {
  @AckField(constraints: ['minLength(2)', 'maxLength(50)'])
  final String name;

  @AckField(constraints: ['email'])
  final String email;

  @AckField(constraints: ['min(18)'])
  final int? age; // Optional field

  // Collects extra properties not defined in the schema
  final Map<String, dynamic> preferences;

  User({
    required this.name,
    required this.email,
    this.age,
    this.preferences = const {},
  });
}
```

After running `dart run build_runner build`, the generator creates a schema variable you can use:

```dart
// Generated in user.g.dart
final userSchema = Ack.object({
  'name': Ack.string().minLength(2).maxLength(50),
  'email': Ack.string().email(),
  'age': Ack.integer().min(18).optional().nullable(),
}, additionalProperties: true);

// Use the generated schema
final userData = {
  'name': 'John Doe',
  'email': 'john@example.com',
  'age': 25,
  // Additional properties are collected into 'preferences'
  'theme': 'dark',
  'language': 'en',
  'notifications': true,
};

final result = userSchema.safeParse(userData);
if (result.isOk) {
  final validData = result.getOrThrow();
  final preferences = validData['preferences'] as Map<String, dynamic>;
  final user = User(
    name: validData['name'] as String,
    email: validData['email'] as String,
    age: validData['age'] as int?,
    preferences: preferences,
  );
  // Access additional properties from the map
  print('Theme: ${preferences['theme']}'); // Outputs: dark
  print('Language: ${preferences['language']}'); // Outputs: en
}
```

*See the [Installation Guide](../getting-started/installation.mdx#code-generator-production-ready) for setup instructions and the generator README for advanced features.*

## Summary

- Ack primarily uses **schema-level configuration** through methods and parameters like `.minLength()`, `.optional()`, `additionalProperties: ...`.
- **Manual schema definition** is the recommended approach for production applications.
- There is currently no central **global configuration** object provided by Ack itself.
