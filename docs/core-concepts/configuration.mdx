---
title: Configuration
---

Ack allows for some configuration settings, although most behavior is controlled directly through the schema definitions when they are created.

## Global Settings (Less Common)

In general, Ack prefers configuration per schema definition rather than global settings. However, if needed, you might manage global aspects like custom format registries or shared validation logic through your own application structure (e.g., dependency injection or service patterns).

*Currently, Ack does not expose a dedicated global configuration object. Configuration is primarily done at the schema level.*

## Schema-Level Configuration

Most "configuration" happens when you define your schemas using the fluent API provided by Ack.

### Required Fields

Use the `required` parameter in [`Ack.object`](./schemas.mdx#object-schema) to specify mandatory fields within an object.

```dart
Ack.object({
  'id': Ack.integer(),
  'name': Ack.string(),
  'email': Ack.string().email().optional() // Email is optional (can be omitted)
}); // id and name are required by default
```

### Additional Properties

Control how extra fields (not defined in the schema) are handled using the `additionalProperties` parameter in [`Ack.object`](./schemas.mdx#object-schema).

```dart
// Allow any extra properties (default behavior)
Ack.object({
  'id': Ack.integer()
}, additionalProperties: true);
// or simply:
Ack.object({
  'id': Ack.integer()
});

// Disallow any extra properties
Ack.object({
  'id': Ack.integer()
}, additionalProperties: false);
```

### Custom Error Messages

Built-in validation rules provide default error messages. For custom error messages, use custom constraints with the `.constrain()` method.
See also: [Custom Error Messages in Error Handling](./error-handling.mdx#custom-error-messages).

```dart
// Built-in constraints use default messages
Ack.string.minLength(5); // Default: "Too short, min 5 characters"
Ack.int.min(18); // Default: "Must be at least 18"

// For custom messages, use custom constraints (see Custom Validation section below)
```

### Custom Validation Logic

Use `.constrain()` to add complex or reusable validation logic.

```dart
class IsPositiveConstraint extends Constraint<double> with Validator<double> {
  const IsPositiveConstraint() : super(
    constraintKey: 'is_positive',
    description: 'Number must be positive'
  );

  @override
  bool isValid(double value) {
    return value > 0;
  }

  @override
  String buildMessage(double value) => 'Number must be positive';
}

// Apply the custom constraint
Ack.double().withConstraint(IsPositiveConstraint());
```
*See the [Custom Validation Guide](../guides/custom-validation.mdx) for details.*

## Code Generation Configuration (Experimental)

The `ack_generator` package provides experimental code generation functionality. However, it is currently incomplete and not recommended for production use.

For production applications, use manual schema definition with the current Ack API:

```dart
// Define schemas manually using the fluent API
final userSchema = Ack.object({
  'name': Ack.string().minLength(2).maxLength(50),
  'email': Ack.string().email(),
  'metadata': Ack.any().optional(), // For flexible additional properties
});

// Validate data
final result = userSchema.validate(userData);
if (result.isOk) {
  final validData = result.getOrThrow();
  // Use validated data to create your models
}
```

*See the [Schema Validation](../core-concepts/typesafe-schemas.mdx) guide for comprehensive examples of manual schema definition.*

## Summary

- Ack primarily uses **schema-level configuration** through methods and parameters like `.minLength()`, `.optional()`, `additionalProperties: ...`.
- **Manual schema definition** is the recommended approach for production applications.
- There is currently no central **global configuration** object provided by Ack itself.