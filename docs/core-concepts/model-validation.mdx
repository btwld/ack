# TypeSafe Models

Ack's TypeSafe Models provide a bridge between Dart's static type system and runtime data validation, giving you the best of both worlds.

```dart
// Define your model with validation annotations
@Schema()
class User {
  @MinLength(2)
  final String name;

  @IsEmail()
  final String email;

  @Min(18)
  final int age;

  User({required this.name, required this.email, required this.age});
}

// Validate and convert raw JSON to a strongly-typed model in one step
try {
  final userData = jsonDecode('{"name":"John","email":"john@example.com","age":30}');
  final user = UserSchema.parse(userData);
  
  print('Welcome ${user.name}!'); // Type-safe access to validated properties
} catch (e) {
  print('Invalid data: $e');
}
```

This document describes Ack's model validation system, which provides a type-safe approach to validating data against Dart models with automatic validation and strong type safety.

## Overview

Ack's model validation system bridges the gap between runtime data validation and static type checking. It lets you define your data structures as regular Dart classes while automatically validating incoming data. This approach provides several benefits:

- **Type Safety**: Work with strongly-typed Dart models instead of loosely-typed maps
- **Automatic Validation**: Data is validated as soon as it's processed
- **Clear Error Handling**: Get structured validation errors with detailed information
- **Code Generation**: Define your models as Dart classes with validation annotations
- **JSON Serialization**: Easily convert between JSON, validated models, and back

## Key Components

The model validation system consists of these main components:

1. **Model Classes**: Regular Dart classes that define your data structure
2. **Schema Classes**: Generated classes that handle validation and conversion
3. **Annotations**: Define validation rules directly on your model properties
4. **Type-Safe API**: Methods for validation and conversion with proper error handling

## Basic Usage

The simplest way to use model validation is with code generation:

### 1. Define Your Model Class

```dart
// file: user.dart
import 'package:ack_generator/ack_generator.dart';

// Use the part directive to include the generated code
part 'user.g.dart';

@Schema()
class User {
  @MinLength(2)
  final String name;

  @IsEmail()
  final String email;

  @Min(0)
  final int? age;

  User({required this.name, required this.email, this.age});
}
```

### 2. Generate the Schema Class

Run the build_runner command to generate the validation code:

```bash
dart run build_runner build --delete-conflicting-outputs
```

This generates a `user.g.dart` file with a `UserSchema` class that handles validation.

### 3. Validate and Convert Data

There are several ways to use the generated validation code:

#### Option 1: Validation with Clear Error Handling

```dart
import 'user.dart';

void main() {
  final userData = {
    'name': 'Jo', // Too short - will fail validation
    'email': 'not-an-email',
    'age': 30,
  };

  // Create schema instance - validation happens automatically
  final userSchema = UserSchema(userData);

  // Check if the data is valid
  if (userSchema.isValid) {
    // Convert to model and use it
    final user = userSchema.toModel();
    print('Valid User: ${user.name}, ${user.email}');
  } else {
    // Handle validation errors
    final error = userSchema.getErrors();
    print('Validation failed: ${error?.message}');
    print('Error path: ${error?.path}');
    // Error output: "Validation failed: String must have at least 2 characters"
    // Error path: ["name"]
  }
}
```

#### Option 2: Direct Parsing with Exceptions

```dart
import 'user.dart';

void main() {
  final userData = {
    'name': 'John Doe',
    'email': 'john@example.com',
    'age': 30,
  };

  try {
    // Parse data directly to model
    // Throws AckException if validation fails
    final user = UserSchema.parse(userData);
    
    // Use the validated model
    print('Valid User: ${user.name}, ${user.email}');
  } catch (e) {
    print('Validation failed: $e');
  }
}
```

#### Option 3: Null-Safe Parsing

```dart
import 'user.dart';

void main() {
  final userData = {
    'name': 'John Doe',
    'email': 'invalid-email', // Will fail validation
  };

  // Returns null if validation fails
  final user = UserSchema.tryParse(userData);
  
  if (user != null) {
    print('Valid User: ${user.name}, ${user.email}');
  } else {
    print('Validation failed');
  }
}
```

## Validating Nested Models

Ack's model validation system handles nested models automatically, providing deep validation:

```dart
// file: address.dart
import 'package:ack_generator/ack_generator.dart';

part 'address.g.dart';

@Schema()
class Address {
  @IsNotEmpty()
  final String street;
  
  @IsNotEmpty()
  final String city;

  Address({required this.street, required this.city});
}

// file: customer.dart
import 'package:ack_generator/ack_generator.dart';
import 'address.dart';

part 'customer.g.dart';

@Schema()
class Customer {
  @MinLength(3)
  final String name;
  
  // Validates using AddressSchema
  final Address address;
  
  // List of addresses, each validated using AddressSchema
  final List<Address>? secondaryAddresses;

  Customer({
    required this.name, 
    required this.address,
    this.secondaryAddresses
  });
}
```

Usage with nested models:

```dart
final customerData = {
  'name': 'John Doe',
  'address': {
    'street': '123 Main St',
    'city': 'Anytown',
  },
  'secondaryAddresses': [
    {
      'street': '456 Business Ave',
      'city': 'Work City',
    }
  ]
};

// Validation happens automatically when creating the schema
final customerSchema = CustomerSchema(customerData);

if (customerSchema.isValid) {
  final customer = customerSchema.toModel();
  print('Customer: ${customer.name}');
  print('Address: ${customer.address.street}, ${customer.address.city}');
  
  // Access nested list items
  if (customer.secondaryAddresses != null) {
    for (final addr in customer.secondaryAddresses!) {
      print('Secondary: ${addr.street}, ${addr.city}');
    }
  }
}
```

## Available Validation Annotations

Ack provides a wide range of validation annotations that you can apply to your model properties:

### String Validation

- `@MinLength(int)`: String must have at least n characters
- `@MaxLength(int)`: String must have at most n characters
- `@Length(int)`: String must have exactly n characters
- `@IsEmail()`: String must be a valid email address
- `@IsUrl()`: String must be a valid URL
- `@Matches(pattern)`: String must match the regular expression pattern
- `@IsNotEmpty()`: String must not be empty
- `@EnumValues(values)`: String must be one of the specified values

### Number Validation

- `@Min(n)`: Number must be greater than or equal to n
- `@Max(n)`: Number must be less than or equal to n
- `@Positive()`: Number must be positive
- `@Negative()`: Number must be negative
- `@MultipleOf(n)`: Number must be a multiple of n

### List Validation

- `@MinItems(n)`: List must have at least n items
- `@MaxItems(n)`: List must have at most n items
- `@Length(n)`: List must have exactly n items
- `@UniqueItems()`: List items must be unique
- `@IsNotEmpty()`: List must not be empty

### Common Validation

- `@Nullable()`: Field is allowed to be null
- `@Required()`: Field is required (useful for nullable types that must be provided)
- `@DefaultValue(value)`: Default value if the field is not provided
- `@Description(text)`: Description for documentation

## JSON Schema Generation

The generated schema classes include methods to convert your schema to JSON Schema format, making it easy to document your APIs:

```dart
// Get the JSON Schema as a Map
final jsonSchema = UserSchema.toJsonSchema();

// Convert to JSON string if needed
import 'dart:convert';
final jsonString = jsonEncode(jsonSchema);
print('JSON Schema:\n$jsonString');
```

## Manual Implementation (Advanced)

While code generation is recommended, you can also implement model validation manually:

```dart
class UserSchema extends SchemaModel<User> {
  UserSchema(Object? data) : super(data);

  @override
  AckSchema getSchema() {
    return Ack.object(
      {
        'name': Ack.string.minLength(2),
        'email': Ack.string.isEmail(),
        'age': Ack.int.min(0).nullable(),
      },
      required: ['name', 'email'],
    );
  }

  @override
  User toModel() {
    if (!isValid) {
      throw AckException(getErrors()!);
    }

    return User(
      name: getValue<String>('name')!,
      email: getValue<String>('email')!,
      age: getValue<int?>('age'),
    );
  }
}
```

## Working with Additional Properties

You can configure how to handle additional properties not defined in your model:

```dart
@Schema(
  additionalProperties: true, // Allow additional properties
  additionalPropertiesField: 'metadata' // Store them in this field
)
class User {
  final String name;
  final String email;
  
  // Field to store additional properties
  final Map<String, dynamic> metadata;

  User({required this.name, required this.email, Map<String, dynamic>? metadata})
      : metadata = metadata ?? {};
}
```

With this configuration, any properties in the input data that aren't defined in the model will be stored in the `metadata` field.

## Conclusion

Ack's model validation system provides a powerful and flexible way to validate data against Dart models. It combines the benefits of strong type checking with runtime validation, making it easier to work with data from external sources like APIs and user input. The code generation approach reduces boilerplate while providing a clean, type-safe API for your application.